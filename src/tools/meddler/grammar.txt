TODO: add oneway modifier for asynchronous exec? check zeroc notes for downsides if any.
TODO: needs declaration might be not needed, since we will use fully-qualified module ids and its possible to derive
needs module names from there...

// EBNF

Const = HexNumber | OctNumber | DecNumber | BinNumber ;
ID = [A-Za-z] { [A-Za-z0-9_] } ;
qualifiedID = ID.ID ;
IDs = ID | qualifiedID , { "," , ID | qualifiedID } ;
IDorConst = ID | Const;
IDlist = ID { "," , ID } ;
builtinType = "int8" | "int16" | "int32" | "int64" | "octet" | "card16" | "card32" | "card64" | "float" | "double" | "boolean";
typeID = ID | qualifiedID | builtinType ;
module = intf+ ;
intf = ["local"] ["final"] "interface" ID ["extends" ID] "{" body "}" ;
body = { needs | exception | typedef | method } ;
needs = { "needs" IDs ";" } ;
fields = typeID , ID , ";" ;
exception = "exception" ID "{" {fields} "}" ;
arrayType = typeID ID ("[" rangeType "]")+ ; //fixme: hard to parse!
recordType = "record" "{" fields+ "}" ID ;
typedef =
    "set" , "{" , IDlist , "}" , ID |
    "range" , IDorConst , ".." , IDorConst , ID |
    typeID , ID |
    "sequence" , "<" , typeID , ">" , ID |
    arrayType |
    recordType ;
arg_spec = ["in"|"out"|"inout"] typeID , ID , { "," , ID } ;
args = arg_spec , { "," , arg_spec } ;
return_spec = "returns" , "(" , {args} , ")" | "never" , "returns" ;
method = ["idempotent"] , ID , "(" , {args} , ")" , return_spec , "raises" , IDs , ";" ;
top_level = intf* ;

// Example code

interface context_v1
{
    needs heap;
    sequence<string> names;
    list() returns (names name_list) raises heap.no_memory;
}

local interface type_system_v1 extends context_v1
{
    type.code alias;

    enum { Boolean, ShortCardinal, Cardinal, LongCardinal,
          ShortInteger, Integer, LongInteger,
          Real, LongReal,
          String,
          Octet, Char,
          Address, Word } predefined;
    set<predefined> predef_flags;
    range 0..15 hexnibble;

    cardinal array_index;
    record { array_index n; alias tc; } array;

    exception not_found { string name; }
    exception bad_code { alias code; }
    exception incompatible {}

    info(alias tc, out type_v1.any rep) returns (interface_v1& scope) raises bad_code;

    size(alias tc) returns (heap_v1.size s) raises bad_code;

    name(alias tc) returns (type_v1.name name) raises bad_code;

    is_type(alias sub, super) returns (boolean result) raises bad_code;

    narrow(type_v1.any a, alias tc) returns (type_v1.val v) raises incompatible;

    unalias(alias tc) returns (alias base) raises bad_code;
}

