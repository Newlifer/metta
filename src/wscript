#!/usr/bin/env python
# -*- coding: utf-8 -*-

import os, sys, Task, Options, Configure, Utils
Configure.autoconfig = 1

APPNAME = 'metta'
VERSION = os.popen("git show --oneline | head -n 1 | cut -d' ' -f1").read().strip()

top = '.'
out = '_build_'

#===================================
# Set up some global vars for build
#===================================

include_dirs = 'kernel kernel/generic nucleus nucleus/x86 runtime'.split()

stl_defines = ['_LIBCPP_NO_IOSTREAMS=1', '_LIBCPP_NO_WCHAR=1', '_LIBCPP_NO_EXCEPTIONS=1']
stl_include_dirs = ['runtime', 'runtime/libc'] #'runtime/libc++/include',

cflags = ['-fvisibility-inlines-hidden',  '-fvisibility=hidden']
flags = '-O1 -g -ffunction-sections -fdata-sections -Wall -Wextra -Werror -mno-mmx -mno-sse -mno-sse2 -mno-3dnow'.split()
non_debug_flags = '-ffunction-sections -fdata-sections' # these make debugging harder
flags += ['-Wno-unused-variable', '-Wno-unused-parameter', '-Wno-unused-private-field', '-Wno-gnu-array-member-paren-init', '-Wno-gcc-compat']

# -emit-llvm and use gold to link all this together
# Problem: no .lds and .map support?? well, partial.
# flags += ['-emit-llvm']

# clang_debug_flag = ['-###']
clang_debug_flag = ['-v', '--trace-includes']

# Lion has deprecated some OpenSSL stuff we use.
toolflags = ['-Wno-deprecated-declarations', '-stdlib=libc++']
toollinkflags = ['-stdlib=libc++']

def normpath(p):
    import posixpath, ntpath
    if sys.platform == 'windows':
        return ntpath.normpath(p)
    else:
        return posixpath.normpath(p)

def options(opt):
    # platform spec "arch-vendor-os", vendor can be omitted.
    # i686-exquance-metta
    # arm-metta

    opt.load('module_template', tooldir='waftools')
    opt.load('toolchain_builder', tooldir='waftools')

    # arch (x86, x64, ppc, ppc64) - a generic cpu architecture (isa)
    # cpu (p4, arm11jsf) - a specific cpu format
    opt.add_option("--arch", action="store", default="x86", help="Select architecture to build for." + '[default: %default]')

    # platform (efi, pc99, hosted) - a generic infrastructure
    # board (vulcan, beagleboard) - a specific infrastructure
    opt.add_option("--platform", action="store", default="pc99", help="Select platform to build for." + '[default: %default]')

    # board usually implies platform, cpu and arch.
    # platform sometimes implies arch.

    # build type - release, debug, profile
    opt.add_option("--build", action="store", default="release", help="Select build type (release/debug/profile/all)." + '[default: %default]')

    opt.add_option("--debug-clang", action="store", default="no", help="Debug clang invocations (default: %default)")

    opt.load('compiler_c')
    opt.load('compiler_cxx')

def clang_tc_dir(tc_dir, path):
    return os.path.join(tc_dir, 'clang', os.sep.join(path.split('/')))

def toolchain_path():
    # Probe cross-branch toolchain first
    # if you are in Metta/master/src
    # the toolchain must be in Metta/toolchain
    # If it doesn't exist, assume local toolchain and pray for the best.
    tc_dir = os.path.join(os.getcwd(), '..', '..', 'toolchain')
    if not os.path.exists(clang_tc_dir(tc_dir, 'bin/clang')):
        tc_dir = os.path.join(os.getcwd(), 'toolchain')
    # You need to amend path with gcc binaries otherwise clang will insist on calling system default one
    # regardless of -gcc-toolchain options (what's that for then, ffs?)
    # VEEERY sanitized version of the env.
    os.environ['PATH'] = os.path.join(tc_dir, 'gcc', 'bin') + ':' + os.path.join(tc_dir, 'gcc', 'i686-pc-elf', 'bin') + ':/usr/local/bin:/bin'
    return normpath(tc_dir)

def configure(conf):
    tc_dir = toolchain_path()
    os.environ['CLANG'] = clang_tc_dir(tc_dir, 'bin/clang++')
    os.environ['CROSS_CC'] = clang_tc_dir(tc_dir, 'bin/clang')
    os.environ['CROSS_CXX'] = clang_tc_dir(tc_dir, 'bin/clang++')
    os.environ['AS'] = os.path.join(tc_dir, 'gcc', 'bin', 'i686-pc-elf-as')
    os.environ['AR'] = os.path.join(tc_dir, 'gcc', 'bin', 'i686-pc-elf-ar')
    os.environ['RANLIB'] = os.path.join('bin', 'true') #os.path.join(tc_dir, 'gcc', 'bin', 'i686-pc-elf-ranlib')
    os.environ['NM'] = os.path.join(tc_dir, 'gcc', 'bin', 'i686-pc-elf-nm')
    # os.environ['AS'] = os.path.join(tc_dir, 'clang', 'bin', 'llvm-as')
    # os.environ['AR'] = os.path.join(tc_dir, 'clang', 'bin', 'llvm-ar')
    # os.environ['RANLIB'] = os.path.join(tc_dir, 'clang', 'bin', 'llvm-ranlib')
    # os.environ['NM'] = os.path.join(tc_dir, 'clang', 'bin', 'llvm-nm')

    # os.environ['CROSS_LD'] = os.path.join(tc_dir, 'gcc', 'bin', 'i686-pc-elf-ld.gold') #os.path.join(tc_dir, 'clang', 'bin', 'llvm-ld')

    conf.check_waf_version(mini='1.6.11')
    conf.load('module_template', tooldir='waftools')
    conf.load('toolchain_builder', tooldir='waftools')

    global flags, cflags, cxxflags, include_dirs, linkflags, toolflags, toollinkflags
    # Configure for given platform
    # Configuration name is composed of architecture, cpu, release
    arch = Options.options.arch
    platform = Options.options.platform
    build = Options.options.build

    # Build and install local clang toolchain if necessary.
    conf.ensure_local_toolchain()

    # Define categories for building:
    # * Base template environment. (ENV)
    # * Kernel and bootstrap, with no external dependencies. (KERNEL_ENV)
    # * Apps/servers running on target system, with possible kernel/boot deps. (APP_ENV)
    # * Tools running on host system, stl/boost ok. (TOOLS_ENV)
    # * Tests running on host system, using boost_unit_test_framework. (TEST_ENV)
    # * Tests running on the target system (KERNEL_TEST_ENV)

    extra_cross_flags = ['-fno-stack-protector'] #'-fno-builtin', , '-fno-leading-underscore']

    conf.load('yasm meddle genpaths', tooldir='waftools')
    conf.load('ar')

    conf.find_program('nm',var='NM')
    # conf.find_program('ld',var='LD')

    conf.load('clang', tooldir='waftools')
    extra_cross_flags += ['-target', 'i686-pc-elf']
    # extra_cross_flags += ['-gcc-toolchain', os.path.join(tc_dir, 'gcc')]
    extra_cross_cxxflags = ['-std=c++11']
    linkflags = '-nostdlib'.split()

    # Link using LLVM gold plugin (@todo factor out dylib_ext())
    if sys.platform == 'darwin':
        linkflags += ['-Wl,--plugin', clang_tc_dir(tc_dir, 'lib/LLVMgold.dylib')]
    else:
        linkflags += ['-Wl,--plugin', clang_tc_dir(tc_dir, 'lib/LLVMgold.so')]

    # linkflags += ['-Wl,--gc-sections', '-Wl,--print-gc-sections']
    # linkflags += ['-Wl,-O1', '-Wl,-zdynsort'] # GNU linker optimization of hash buckets.

    #=========================
    # DEBUG CLANG INVOCATIONS
    #=========================

    if Options.options.debug_clang == 'yes':
        flags += clang_debug_flag
        linkflags += clang_debug_flag
        toolflags += clang_debug_flag
        toollinkflags += clang_debug_flag

    # extra_cross_flags += ['-no-canonical-prefixes']

    system_header_dir = map(lambda d: '-isystem' + d, [os.getcwd()+'/runtime/libc++/include', clang_tc_dir(tc_dir, 'lib/clang/3.2/include')])

    cxxflags = cflags

    # Generate config.h
    # *_V options generate huge amount of output, beware.
    conf.define('ARCH', arch)
    conf.define('PLATFORM', platform)
    conf.define('BUILD', build)
    conf.define('CONFIG_INLINING', 1)
    conf.define('CONFIG_DEBUG_SYMBOLS', 1)
    conf.define('SYSTEM_DEBUG', 0)
    conf.define('SYSTEM_VERBOSE_DEBUG', 0)
    conf.define('HEAP_DEBUG', 0)
    conf.define('MEMORY_DEBUG', 1)
    conf.define('ELF_LOADER_DEBUG', 0)
    conf.define('ELF_RELOC_DEBUG_V', 0)
    conf.define('BOOTIMAGE_DEBUG', 0)
    conf.define('DWARF_DEBUG', 0)
    conf.define('RAMTAB_DEBUG', 0)
    conf.define('TOOLS_DEBUG', 1) # Overarching tools debugging enabler, disable to turn off all tools debugging prints.
    conf.define('MEDDLER_DEBUG', 0) # Per-tool: Enable Meddler debug prints. Needs TOOLS_DEBUG.
    conf.define('CONFIG_COMPORT', 0)
    conf.define('CONFIG_COMSPEED', 115200)
    conf.define('CONFIG_X86_PSE', 1)
    conf.define('CONFIG_X86_PGE', 1)
    conf.define('CONFIG_X86_FXSR', 1)
    conf.define('CONFIG_X86_SYSENTER', 1)
    conf.define('CONFIG_IOAPIC', 1)
    conf.write_config_header('kernel/config.h')

    # Flag that we're building under/for Metta.
    # Value is metta release number, monotonically increasing with each public release.
    metta_flag = "__Metta__=1"
    kernel_flags = '-fno-strict-aliasing -ffreestanding -nostdinc'.split()

    # --gc-sections ruins everything - TODO: add attribute(section, used) to custom sections!
    kernel_linkflags = ['-target', 'i686-pc-elf'] #'-ffreestanding'.split() # -Wl,--gc-sections
    # kernel_linkflags = ['--retain-symbols-file', 'retain.file',
        # '--plugin-opt', 'mtriple=i686-pc-elf', '--plugin-opt', 'also-emit-llvm']
    # ../../../../toolchain/gcc/bin/i686-pc-elf-ld.gold \
    # -no-lto -O0 --plugin ../../../../toolchain/clang/lib/LLVMgold.dylib \
    # -o interface_repository interface_repository.bc --plugin-opt mtriple=i686-pc-elf -Map ir.map -r

    # kernel_linkflags = ['--debug', 'script', '--cref', '-r', '-y', '_GLOBAL_OFFSET_TABLE_', '--print-icf-sections', '--print-gc-sections', '--error-unresolved-symbols']

    # gold options
    # --compress-debug-sections zlib
    # --debug [all,files,script,task][,...] Turn on debugging
    # --verbose                   Synonym for --debug=files
    # --defsym SYMBOL=EXPRESSION  Define a symbol   (hmm, might be useful?)
    # --incremental               Do an incremental link if possible; otherwise, do a full link and prepare output for incremental linking
    # --no-incremental            Do a full link (default)
    # --just-symbols FILE         Read only symbol values from FILE  -- don't read symbols "contents"
    # -Map MAPFILENAME Write map file
    # --plugin-opt OPTION         Pass an option to the plugin 
    # LLVMgold options:
    # generate-api-file
    # mcpu=
    # extra-library-path=
    # mtriple=
    # obj-path=
    # emit-llvm
    # also-emit-llvm
    # also-emit-llvm=<path>
    #
    #  --print-symbol-counts FILENAME    Print symbols defined and used for each input
    # -q, --emit-relocs           Generate relocations in output -- will this finally work? versus
    # -r, -relocatable            Generate relocatable output

    # --retain-symbols-file FILE  keep only symbols listed in this file
    # --section-ordering-file FILENAME Layout sections in the order specified.

    # -S, --strip-debug           Strip debugging information
    # --strip-debug-non-line      Emit only debug line number information
    # --strip-debug-gdb           Strip debug symbols that are unused by gdb (at least versions <= 6.7)
    # --strip-lto-sections        Strip LTO intermediate code sections

    # --icf [none,all,safe]       Identical Code Folding. '--icf=safe' Folds ctors, dtors and functions whose pointers are definitely not taken.

    # --stats                     Print resource usage statistics
    # --sysroot DIR               Set target system root directory
    # --threads                   Run the linker multi-threaded

    # --section-start SECTION=ADDRESS Set address of section
    # -Tbss ADDRESS Set the address of the bss segment
    # -Tdata ADDRESS Set the address of the data segment
    # -Ttext ADDRESS Set the address of the text segment
    # --unresolved-symbols=report-all
    # --error-unresolved-symbols  Report unresolved symbols as errors

    # ENVIRONMENT

    # Set up common environment variables
    conf.env.append_unique('CCFLAGS', cflags + flags)
    conf.env.append_unique('CXXFLAGS', cxxflags + flags)
    conf.env.append_unique('YASM_FLAGS', ['-f', 'elf'])

    # conf.env['variant'] = arch + '-' + platform + '-' + build

    # Base template env
    # conf.env.set_variant(conf.env['variant'])
    # conf.set_env_name('ENV', conf.env)
    # conf.setenv('ENV') # Activate the environment
    conf.env.append_unique('INCLUDE_DIRS', include_dirs)
    conf.env.append_unique('INCLUDE_DIRS', 'interfaces')
    conf.env.append_unique('INCLUDE_DIRS', 'interfaces/nemesis')
    # Set arch-specific include paths
    conf.env.append_unique('INCLUDE_DIRS', map(lambda d: d + arch, 'kernel/arch/'.split()))
    conf.env.append_unique('INCLUDE_DIRS', map(lambda d: d + platform, 'kernel/platform/'.split()))
    # Append shared includes after, so we could override in arch-specific ones.
    conf.env.append_unique('INCLUDE_DIRS', 'kernel/arch/shared kernel/platform/shared'.split())

    # Copy template env to specific ones
    env_base = conf.env

    # Config for running tests
    conf.setenv('TEST_ENV', env_base)
    conf.env.append_unique('CXXFLAGS', ['-fexceptions'])
    conf.env.append_unique('DEFINES', ['UNIT_TESTS'])
    conf.env['LIB_TEST'] = 'boost_unit_test_framework' # set uselib

    # Config for building kernel
    conf.setenv('KERNEL_ENV', env_base)
    conf.env.append_unique('INCLUDE_DIRS', stl_include_dirs)
    #conf.env.append_unique('INCLUDE_DIRS', system_header_dir)
    conf.env.append_unique('DEFINES', metta_flag)
    conf.env.append_unique('DEFINES', ['BOCHS_IO_HACKS']) # debugging hacks for bochs
    conf.env.append_unique('DEFINES', stl_defines)
    conf.env.append_unique('CCFLAGS', extra_cross_flags + kernel_flags + system_header_dir)
    conf.env.append_unique('CXXFLAGS', extra_cross_flags + extra_cross_cxxflags + system_header_dir)
    conf.env.append_unique('CXXFLAGS', kernel_flags)
    conf.env.append_unique('CXXFLAGS', '-fno-rtti -fno-exceptions'.split())
    conf.env.append_value('LINKFLAGS',  linkflags + kernel_linkflags)
    if os.environ.has_key('CROSS_CC'):
        conf.env['CC'] = os.environ['CROSS_CC']
        conf.env['LINK_CC'] = os.environ['CROSS_CC']
    if os.environ.has_key('CROSS_CXX'):
        conf.env['CXX'] = os.environ['CROSS_CXX']
        conf.env['LINK_CXX'] = os.environ['CROSS_CXX']
    if os.environ.has_key('CROSS_LD'):
        conf.env['LINK_CC'] = os.environ['CROSS_LD']
        conf.env['LINK_CXX'] = os.environ['CROSS_LD']
    conf.env.append_unique('CCFLAGS', ['-m32'])
    conf.env.append_unique('CXXFLAGS', ['-m32'])
    # conf.env.append_unique('LINKFLAGS', ['-m32'])

    env_kernel = conf.env

    # Config for building system apps
    conf.setenv('APP_ENV', env_kernel)

    # Use host cc for building tools and local tests - do we need target tests as well?
    conf.setenv('TOOLS_ENV', env_base)
    conf.env.append_unique('CXXFLAGS', extra_cross_cxxflags)
    # conf.env.append_unique('CXXFLAGS', '-fno-rtti -fno-exceptions'.split()) -- @todo LLVM requires this!
    if os.environ.has_key('HOST_CC'):
        conf.env['CC'] = os.environ['HOST_CC']
        conf.env['LINK_CC'] = os.environ['HOST_CC']
    if os.environ.has_key('HOST_CXX'):
        conf.env['CXX'] = os.environ['HOST_CXX']
        conf.env['LINK_CXX'] = os.environ['HOST_CXX']

    conf.env.append_unique('CCFLAGS', toolflags)
    conf.env.append_unique('CXXFLAGS', toolflags)
    conf.env.append_unique('LINKFLAGS',  toollinkflags)

    # set uselib for TOOLS_ENV
    conf.env.STLIB_UUID = 'uuid'
    if sys.platform == 'darwin':
        conf.env.LIBPATH_UUID = '/usr/local/opt/ossp-uuid/lib'
        conf.env.INCLUDES_UUID = '/usr/local/opt/ossp-uuid/includes'

    if sys.platform == 'darwin':
        conf.env.LIB_OPENSSL = 'crypto'
    else:
        conf.env.LIB_OPENSSL = 'ssl'

    conf.env.STLIBPATH_LLVM = clang_tc_dir(tc_dir, 'lib')
    conf.env.INCLUDES_LLVM = clang_tc_dir(tc_dir, 'include')
    conf.env.STLIB_LLVM = ['LLVMSupport']
    conf.env.LIB_LLVM = 'pthread'

    conf.env.LIBPATH_LIBCXX = os.path.join(tc_dir, 'libcxx', 'lib')
    conf.env.INCLUDES_LIBCXX = os.path.join(tc_dir, 'libcxx', 'include')
    conf.env.LIB_LIBCXX = ['c++']

    env_host_tests = conf.env

    conf.setenv('TEST_ENV', env_host_tests)

def tools_env(bld):
    return bld.all_envs['TOOLS_ENV'].derive()

def build(bld):
    tc_dir = toolchain_path()

    arch = Options.options.arch
    platform = Options.options.platform

    # Tool to parse interface files.
    meddler = bld.program(
        target = 'meddler',
        source = map(lambda f: 'tools/meddler/' + f + '.cpp', 'meddler parser lexer ast symbol_table emit_cpp'.split()),
        use = 'LLVM OPENSSL LIBCXX',
        env = tools_env(bld),
        defines = ['__STDC_LIMIT_MACROS', '__STDC_CONSTANT_MACROS']
    )
    meddler.includes = meddler.env.INCLUDE_DIRS #[clang_tc_dir(tc_dir, 'include')] + 

    # List interfaces sorted alphabetically.
    interface_files = ['activation_dispatcher_factory_v1', 'activation_dispatcher_v1', 'activation_v1', 'binder_v1', 'binder_callback_v1', 'chained_handler_v1', 'channel_notify_v1', 'channel_v1', 'choice_v1', 'closure', 'domain_v1', 'enum_v1', 'event_v1', 'events_v1', 'exports_table_v1', 'fault_handler_v1', 'frame_allocator_v1', 
                       'frames_module_v1', 'gatekeeper_v1', 'gatekeeper_factory_v1', 'heap_v1', 'heap_factory_v1', 'idc_v1', 'idc_client_binding_v1', 'idc_offer_v1', 'idc_service_v1', 'interface_v1', 'map_card64_address_v1', 'map_card64_address_factory_v1', 
                       'map_string_address_v1', 'map_string_address_factory_v1', 'map_string_address_iterator_v1',
                       'memory_v1', 'mmu_module_v1', 'mmu_v1', 
                       'naming_context_v1', 'naming_context_factory_v1', 'operation_v1', 'pervasives_v1', 'protection_domain_v1', 'ramtab_v1', 'record_v1',
                       'stretch_allocator_module_v1', 'stretch_allocator_v1', 'stretch_driver_module_v1', 'stretch_driver_v1', 'stretch_table_v1', 
                       'stretch_table_module_v1', 'stretch_v1', 'system_frame_allocator_v1', 'system_stretch_allocator_v1', 'threads_factory_v1', 'thread_hooks_v1', 'thread_v1', 'threads_manager_v1', 'threads_v1', 'time_notify_v1', 'time_v1', 'timer_v1', 'types',
                       'type_system_v1', 'type_system_f_v1', 'type_system_factory_v1', 'vcpu_v1',
                       # Temporary interfaces "borrowed" from Nemesis
                       'nemesis/exception_v1', 'nemesis/exception_support_v1', 'nemesis/exception_support_setjmp_v1', 'nemesis/exception_system_v1'
                       ]

    # Now generate interface files.
    interfaces = bld.stlib(
        source = map(lambda d: 'interfaces/'+d+'.if', interface_files),
        includes = ['../interfaces',  '../interfaces/nemesis'], # TODO: make meddle produce relative paths properly!!
        target = 'interfaces',
        features = 'cxx',
        use = 'LIBCXX'
    )
    interfaces.env = bld.all_envs['KERNEL_ENV'].derive()
    interfaces.includes += interfaces.env['INCLUDE_DIRS'] # For building the C part

    repository = bld.program(
        source = [],
        target = 'interface_repository',
        features = 'cxx cxxprogram',
        env = bld.all_envs['KERNEL_ENV'].derive()
    )
    repository.includes = repository.env.INCLUDE_DIRS
    repository.env.append_unique('LINKFLAGS', ['-r']) # Components are relocatable
    if platform != 'hosted':
        repository.env.append_unique('LINKFLAGS', ['-Wl,-T,../modules/component.lds', '-Wl,-Map,interface_repository.map'])

    # Make bootimage components.
    bld.all_comp_targets = []
    bld.recurse("modules")

    # Target libcxx
    libcxx = bld.stlib(
        source = 'runtime/libc++/src/hash.cpp runtime/libc++/src/vector_inst.cpp runtime/libc++/src/string.cpp',
        target = 'cxx',
        env = bld.all_envs['KERNEL_ENV'].derive()
    )
    libcxx.includes = libcxx.env.INCLUDE_DIRS

    # Common libraries
    # TODO: add conditional source compilation: if arch/<cpu>/runtime/ directory has optimized versions, use them.
    libdebug = bld.stlib(
        source = map(lambda d: "kernel/arch/"+arch+"/"+d, 'panic.cpp debugger.cpp registers.s'.split()),
        target = 'debug',
        env = bld.all_envs['KERNEL_ENV'].derive()
    )
    libdebug.includes = libdebug.env.INCLUDE_DIRS

    # Runtime is C++ runtime support library, it has no other dependencies.
    runtime = bld.stlib(
        source = map(lambda d: 'runtime/' + d + '.cpp', 'memutils cstring'.split()) + ['runtime/setjmp.s'],
        target = 'runtime',
        env = bld.all_envs['KERNEL_ENV'].derive()
    )
    if platform != 'hosted': runtime.source += map(lambda d: 'runtime/' + d + '.cpp', 'g++support stdlib newdelete'.split())
    runtime.includes = runtime.env.INCLUDE_DIRS

    # Minruntime is a version of runtime with dynamic memory allocation replaced with dummy implementation.
    minruntime = bld.stlib(
        source = map(lambda d: 'runtime/' + d + '.cpp', 'dummy_delete memutils cstring'.split()),
        target = 'minruntime',
        env = bld.all_envs['KERNEL_ENV'].derive()
    )
    if platform != 'hosted': minruntime.source += map(lambda d: 'runtime/' + d + '.cpp', 'g++support'.split())
    minruntime.includes = minruntime.env.INCLUDE_DIRS

#@FIXME: toolruntime should build with host toolchain and host bitness! (now mismatches -m32 with -m64 for linking... by using wrong AR)
    #toolruntime = bld.stlib(
    #    source = 'runtime/memutils.cpp runtime/cstring.cpp'.split(),
    #    target = 'toolruntime',
    #    env = bld.all_envs['TOOLS_ENV'].derive(),
    #    includes = include_dirs
    #)

    commons = bld.stlib(
        source = map(lambda d: 'kernel/generic/'+d+'.cpp', 'elf_parser console module_loader'.split()),
        target = 'common',
        env = bld.all_envs['KERNEL_ENV'].derive()
    )
    commons.includes = commons.env.INCLUDE_DIRS

    bld.recurse('kernel/platform/'+Options.options.platform)

    libkernel = bld.stlib(
        source = map(lambda d: 'kernel/arch/'+arch+'/' + d, 'bootinfo.cpp bootimage.cpp'.split()) + ['kernel/arch/shared/bootinfo.cpp'],
        target = 'kernel',
        env = bld.all_envs['KERNEL_ENV'].derive()
    )
    libkernel.includes = libkernel.env.INCLUDE_DIRS

    # Tests
#    tests = bld.new_task_gen('cxx', 'program')
#    tests.source = 'tests/test_suite_main.cpp'.split()# tests/test_rbtree.cpp
#    tests.env = bld.env_of_name('TEST_ENV').copy()
#    tests.includes = tests.env['INCLUDE_DIRS']
#    tests.uselib = 'TEST'
#    tests.target = 'testrunner'

    slebtest = bld.program(
        source = 'tests/slebtest.cpp',
        target = 'slebtest',
        env = bld.all_envs['TEST_ENV'].derive(),
        use = 'toolcommon LIBCXX'
    )
    slebtest.gen_incpaths('')

    # stltest = bld.new_task_gen('cxx', 'program')
    # stltest.source = 'tests/stl_include_test.cpp'
    # stltest.env = bld.env_of_name('KERNEL_ENV').copy()
    # stltest.includes = stltest.env['INCLUDE_DIRS']
    # stltest.target = 'stltest'

    # toolcommons = bld.stlib(
    #     source = map(lambda d: 'kernel/generic/'+d+'.cpp', 'elf_parser'.split()),
    #     target = 'toolcommon',
    #     env = bld.all_envs['TOOLS_ENV'].derive()
    # )
    # toolcommons.includes = toolcommons.env.INCLUDE_DIRS

    # parsedwarf = bld.program(
    #     source = map(lambda f: 'tools/parsedwarf/'+f+'.cpp', 'parsedwarf form_reader datarepr dwarf_info dwarf_parser dwarf_aranges dwarf_abbrev dwarf_lines'.split()),
    #     target = 'parsedwarf',
    #     use = 'toolruntime toolcommon'
    # )
    # parsedwarf.env = bld.all_envs['TOOLS_ENV'].derive()
    # parsedwarf.includes = parsedwarf.env.INCLUDE_DIRS

    # Tools
    bld.recurse("tools/mettafs")

    # Tool to build bootimage.
    buildboot = bld.program(
        source = 'tools/buildboot/buildboot.cpp',
        target = 'buildboot',
        env = bld.all_envs['TOOLS_ENV'].derive(),
        use = 'LIBCXX'
    )
    buildboot.env.append_unique('CXXFLAGS', ['-fexceptions'])
    buildboot.includes = buildboot.env.INCLUDE_DIRS

    ################################
    # FINAL OUTPUTS
    ################################

    if platform != 'hosted':
        # Initial loader.
        # Initial loader provides boot sequence abstraction for the kernel.
        # It may also choose which kernel to boot depending on the environment.

        ################################################################################################
        # Launcher.
        #
        # Launcher sets up a necessary environment (for example device trees),
        # pulls a necessary version of the nucleus from the boot image, initializes it,
        # pulls a right copy of root domain from the boot image and passes control to it, switching to ring3 along the way.
        # The privileged execution ends with the launcher and the nucleus.
        # The rest of the loading is done by the root domain.
        ################################################################################################

        launcher = bld.program(
            target = 'launcher.sys',
            source = map(lambda f: 'launcher/pc99/' + f, 'loader.s loader-ia32.cpp loader-multiboot.cpp multiboot-ia32.cpp'.split())
                + ['launcher/loader.cpp', 'modules/tcb/root_domain/root_domain.cpp', 'launcher/x86/startup.cpp']
                + map(lambda f: 'kernel/arch/x86/' + f, 'bootinfo.cpp continuation.s'.split()),
            use = 'interfaces common platform kernel runtime debug cxx',
            env = bld.all_envs['KERNEL_ENV'].derive()
        )
        launcher.env.append_unique('LINKFLAGS', ['-Wl,-T,../launcher/pc99/launcher.lds', '-Wl,-Map,launcher.map'])
        launcher.includes = launcher.env.INCLUDE_DIRS + ['launcher', 'launcher/pc99', 'modules/tcb/root_domain']

        ################################################################################################
        # Nucleus.
        #
        # Privileged mode ring0 nucleus.
        # Nucleus is the only ring0 privileged part of the system.
        # It includes interrupt handlers and some minimal syscall processing.
        ################################################################################################

        nucleus = bld.program(
            target = 'nucleus.sys',
            source = map(lambda f: 'nucleus/x86/' + f, 'idt.cpp isr.cpp interrupt.s init_nucleus.cpp nucleus.cpp'.split()),
            use = 'common kernel minruntime platform debug',
            env = bld.all_envs['KERNEL_ENV'].derive()
        )
        nucleus.env.append_unique('LINKFLAGS', ['-r']) # nucleus is relocatable.
        nucleus.env.append_unique('LINKFLAGS', ['-Wl,-T,../nucleus/x86/nucleus.lds', '-Wl,-Map,nucleus.map'])
        nucleus.gen_incpaths('')

        bld.undef_check(launcher.target)
        bld.undef_check(nucleus.target)

    # if platform == 'hosted':
        # Generate a single executable to run whole OS as an application.
        # hosted = bld.program(
            # target = 'mettanode'
        # )

    #Check and add all output modules.
    nm = []
    for tg in bld.all_comp_targets:
        nm.append(tg)
    nm.append(nucleus.target)

    # print "All outputs: "+", ".join(nm)

    # target_variant = Options.options.arch + '-' + Options.options.platform + '-' + Options.options.build
    # print "Target variant: "+target_variant

    bld(
        source = ['buildboot', 'kernel/platform/'+Options.options.platform+'/bootimage.lst', 'interface_repository'] + nm,
        target = 'init.img',
        # rule = '${SRC[0].abspath(env)} '+target_variant+'/ ${SRC[1].abspath(env)} ${TGT}', # note / after target-variant
        rule = '${SRC[0].abspath()} ./ ${SRC[1].abspath()} ${TGT}',
        name = 'init.img',
        depends_on = 'buildboot'
    )

    bld(
        features = 'subst',
        source = 'tools/mkbootimg/menu.lst.in',
        target = 'tools/mkbootimg/menu.lst.cd',
        ROOT = 'cd'
    )

    bld(
        source = 'launcher.sys init.img tools/mkbootimg/images.sh tools/mkbootimg/menu.lst.cd',
        target = 'metta.iso',
        rule = './images.sh',
        cwd = bld.path.find_dir('tools/mkbootimg').abspath(),
        after = 'init.img'
    )

# kate: indent-width 4; replace-tabs on;
# vim: set et sw=4 ts=4 sts=4 cino=(4 :
