#!/usr/bin/env python
# -*- coding: utf-8 -*-

import os, Task, Options, Configure, Utils, misc
Configure.autoconfig = 1

# FIXME: Could use bzr python modules, too.
VERSION = os.popen("bzr version-info|grep revno|cut -d' ' -f2").read().strip()
APPNAME = 'metta'

srcdir = '.'
blddir = '_build_'

include_dirs = 'common runtime'.split()

# Local SGI STL instance.
stl_defines = '_NOTHREADS __STL_NO_EXCEPTION_HEADER __STL_NO_BAD_ALLOC __STL_NO_DRAND48'.split()
stl_include_dirs = ['runtime/stl']

cflags = '-Wall -Wextra -Werror'.split()
cflags += ['-O0', '-g']#'-Os'] #FIXME: builddep
cxxflags = cflags + ['-std=gnu++0x']
linkflags = '-nostdlib -nostartfiles -nodefaultlibs'.split()
flags = '-fno-builtin -fno-stack-protector -fno-leading-underscore -ffunction-sections -fdata-sections'.split()

def set_options(opt):
    # platform spec "arch-vendor-os", vendor can be omitted.
    # i686-exquance-metta
    # arm-metta

    opt.tool_options('compiler_cc compiler_cxx')

    # arch (x86, x86-64, ppc, ppc64) - a generic cpu architecture (isa)
    # cpu (p4, arm11jsf) - a specific cpu format
    opt.add_option("--arch", action="store", default="x86", help="Select architecture to build for." + '[default: %default]')

    # platform (efi, pc99) - a generic infrastructure
    # board (vulcan, beagleboard) - a specific infrastructure
    opt.add_option("--platform", action="store", default="pc99", help="Select platform to build for." + '[default: %default]')

    # build type - release, debug, profile
    opt.add_option("--build", action="store", default="release", help="Select build type (release/debug/profile)." + '[default: %default]')


def configure(conf):
    # Configure for given platform
    # Configuration name is composed of architecture, cpu, release
    arch = Options.options.arch
    platform = Options.options.platform
    build = Options.options.build

    # Define categories for building:
    # * Base template environment. (ENV)
    # * Kernel and bootstrap, with no external dependencies. (KERNEL_ENV)
    # * Apps/servers running on target system, with possible kernel/boot deps. (APP_ENV)
    # * Tools running on host system, stl/boost ok. (TOOLS_ENV)
    # * Tests running on host system, using boost_unit_test_framework. (TEST_ENV)

    # TODO: try to use yasm, but allow fallback to NASM
    # Ditto for llvm
    conf.check_tool('compiler_cc compiler_cxx yasm misc', tooldir='waftools') # FIXME: gcc detection per-config for x-compile?

    # Set up common environment variables
    conf.env.append_unique('CCFLAGS', cflags + flags)
    conf.env.append_unique('CXXFLAGS', cxxflags + flags)
    conf.env.append_unique('YASM_FLAGS', ['-f', 'elf'])

    conf.env['variant'] = arch + '-' + platform + '-' + build

    # Base template env
    conf.env.set_variant(conf.env['variant'])
    conf.set_env_name('ENV', conf.env)
    conf.setenv('ENV') # Activate the environment
    conf.env.append_unique('INCLUDE_DIRS', include_dirs)
    # Set arch-specific include paths
    conf.env.append_unique('INCLUDE_DIRS', map(lambda d: d + arch, 'arch/'.split()))
    conf.env.append_unique('INCLUDE_DIRS', map(lambda d: d + platform, 'platform/'.split()))

    # Generate config.h
    conf.define('ARCH', arch)
    conf.define('PLATFORM', platform)
    conf.define('BUILD', build)
    conf.define('CONFIG_INLINING', 1)
    conf.define('CONFIG_DEBUG_SYMBOLS', 1)
    conf.define('HEAP_DEBUG', 1)
    conf.define('MEMORY_DEBUG', 1)
    conf.define('ELF_LOADER_DEBUG', 1)
    conf.define('DWARF_DEBUG', 0)
    conf.write_config_header('common/config.h')

    # Copy template env to specific ones
    conf.set_env_name('KERNEL_ENV', conf.env.copy())
    conf.set_env_name('APP_ENV', conf.env.copy())
    conf.set_env_name('TOOLS_ENV', conf.env.copy())
    conf.set_env_name('TEST_ENV', conf.env.copy())

    # Config for running tests
    conf.setenv('TEST_ENV')
    conf.env.append_unique('CXXFLAGS', ['-fexceptions'])
    conf.env.append_unique('CXXDEFINES', ['UNIT_TESTS'])
    conf.env['LIB_TEST'] = 'boost_unit_test_framework' # set uselib

    # Flag that we're building under/for Metta.
    # Value is metta release number, monotonically increasing with each public release.
    metta_flag = "__Metta__=1"
    kernel_flags = '-ffreestanding -fno-strict-aliasing'.split() #-nostdinc
    # --gc-sections ruins everything
    kernel_linkflags = '-ffreestanding'.split() # -Wl,--gc-sections -Wl,--print-gc-sections

    # Config for building kernel
    conf.setenv('KERNEL_ENV')
    conf.env.append_unique('INCLUDE_DIRS', stl_include_dirs)
    conf.env.append_unique('CDEFINES', metta_flag)
    conf.env.append_unique('CXXDEFINES', metta_flag)
    conf.env.append_unique('CXXDEFINES', ['BOCHS_IO_HACKS']) # debugging hacks for bochs
    conf.env.append_unique('CXXDEFINES', stl_defines)
    conf.env.append_unique('CCFLAGS', kernel_flags)
    conf.env.append_unique('CXXFLAGS', kernel_flags)
    conf.env.append_unique('CXXFLAGS', '-fno-rtti -fno-exceptions'.split())
    conf.env.append_unique('LINKFLAGS', kernel_linkflags + linkflags)

    # Config for building system apps
    conf.setenv('APP_ENV')
    conf.env.append_unique('INCLUDE_DIRS', stl_include_dirs)
    conf.env.append_unique('CDEFINES', metta_flag)
    conf.env.append_unique('CXXDEFINES', metta_flag)
    conf.env.append_unique('CXXDEFINES', ['BOCHS_IO_HACKS']) # debugging hacks for bochs
    conf.env.append_unique('CXXDEFINES', stl_defines)
    conf.env.append_unique('CCFLAGS', kernel_flags)
    conf.env.append_unique('CXXFLAGS', kernel_flags)
    conf.env.append_unique('LINKFLAGS', kernel_linkflags + linkflags)

    # We cannot build target tools on the host system properly atm, since it mixes our local and system STL.

def build(bld):
    arch = Options.options.arch

    # TODO: add conditional source compilation: if arch/<cpu>/runtime/ directory has optimized versions, use them.
    runtime = bld.new_task_gen('cxx', 'staticlib')
    runtime.source = map(lambda d: 'runtime/' + d + '.cpp', 'g++support newdelete memutils cstring stdlib'.split())
    runtime.env = bld.env_of_name('KERNEL_ENV').copy()
    runtime.includes = runtime.env['INCLUDE_DIRS']
    runtime.target = 'runtime'

    toolruntime = bld.new_task_gen('cxx', 'staticlib')
    toolruntime.source = 'runtime/memutils.cpp runtime/cstring.cpp'.split()
    toolruntime.env = bld.env_of_name('TOOLS_ENV').copy()
    toolruntime.includes = include_dirs
    toolruntime.target = 'toolruntime'

    commons = bld.new_task_gen('cxx', 'staticlib')
    commons.source = 'common/elf_parser.cpp common/elf_loader.cpp common/console.cpp'.split()
    commons.env = bld.env_of_name('KERNEL_ENV').copy()
    commons.includes = commons.env['INCLUDE_DIRS']
    commons.target = 'common'

    platform = bld.new_task_gen('cxx', 'staticlib')
    platform.source = map(lambda d: "platform/" + Options.options.platform + "/" + d, 'multiboot.cpp default_console.cpp'.split()) + map(lambda d: "arch/"+arch+"/"+d, 'panic.cpp debugger.cpp registers.s'.split())
    platform.env = bld.env_of_name('KERNEL_ENV').copy()
    platform.includes = platform.env['INCLUDE_DIRS']
    platform.target = 'platform'

    libkernel = bld.new_task_gen('cxx', 'staticlib')
    libkernel.source = map(lambda d: 'arch/x86/' + d, 'x86_frame_allocator.cpp x86_protection_domain.cpp page_directory.cpp cpu.cpp'.split()) + ['common/stretch_driver.cpp'] # TODO: This should be in arch/x86/ too.
    libkernel.env = bld.env_of_name('KERNEL_ENV').copy()
    libkernel.includes = libkernel.env['INCLUDE_DIRS']
    libkernel.target = 'kernel'

    tests = bld.new_task_gen('cxx', 'program')
    tests.source = 'tests/test_suite_main.cpp'.split()# tests/test_rbtree.cpp
    tests.env = bld.env_of_name('TEST_ENV').copy()
    tests.includes = tests.env['INCLUDE_DIRS']
    tests.uselib = 'TEST'
    tests.target = 'testrunner'

    slebtest = bld.new_task_gen('cxx', 'program')
    slebtest.source = 'tests/slebtest.cpp'
    slebtest.env = bld.env_of_name('TEST_ENV').copy()
    slebtest.includes = slebtest.env['INCLUDE_DIRS']
    slebtest.target = 'slebtest'
    #slebtest.uselib_local = 'toolruntime common'

    parsedwarf = bld.new_task_gen('cxx', 'program')
    parsedwarf.source = map(lambda f: 'tools/parsedwarf/'+f+'.cpp', 'parsedwarf form_reader datarepr dwarf_info dwarf_parser dwarf_aranges dwarf_abbrev dwarf_lines'.split())
    parsedwarf.env = bld.env_of_name('TOOLS_ENV').copy()
    parsedwarf.includes = parsedwarf.env['INCLUDE_DIRS']
    parsedwarf.target = 'parsedwarf'
    parsedwarf.uselib_local = 'toolruntime common'

    #mkinitfs = bld.new_task_gen('cxx', 'program')
    #mkinitfs.source = 'tools/mkinitfs/mkinitfs.cpp'
    #mkinitfs.env = bld.env_of_name('TOOLS_ENV').copy()
    #mkinitfs.env.append_unique('CXXFLAGS', ['-fexceptions'])
    #mkinitfs.env.append_unique('LINKFLAGS', '-lstdc++') # hm, why is this needed?
    #mkinitfs.includes = mkinitfs.env['INCLUDE_DIRS']
    #mkinitfs.target = 'mkinitfs'

    kickstart = bld.new_task_gen('cxx', 'program')
    kickstart.source = map(lambda f: 'arch/' + arch + '/' + f, 'loader.s kickstart.cpp isr.cpp idt.cpp interrupt.s'.split())
    # isr.cpp interrupt.s initfs.cpp c++boot.cpp kickstart.lds
    kickstart.env = bld.env_of_name('KERNEL_ENV').copy()
    kickstart.env.append_unique('LINKFLAGS', ['-T', '../arch/'+arch+'/kickstart.lds', '-Wl,-Map,kickstart.map'])
    kickstart.includes = kickstart.env['INCLUDE_DIRS']
    kickstart.target = 'kickstart.sys'
    kickstart.uselib_local = 'platform common kernel runtime'

    #bld.new_task_gen(
        #source = 'mkinitfs vesper/arch-x86/kickstart/component.lst',#arch dep
        #target = 'initfs.img',
        #rule = '${SRC[0].abspath(env)} ${SRC[1].abspath(env)} ${TGT}',
        #name = 'initfs.img',
        #after = 'cxx_link'
    #)

    bld.new_task_gen('subst',
        source = 'tools/mkbootimg/menu.lst.in',
        target = 'tools/mkbootimg/menu.lst.cd',
        dict = {'ROOT': 'cd'}
    )

    bld.new_task_gen('subst',
        source = 'tools/mkbootimg/menu.lst.in',
        target = 'tools/mkbootimg/menu.lst.fd0',
        dict = {'ROOT': 'fd0'}
    )

    bld.new_task_gen(# arch/'+arch+'/nucleus.bin initfs.img
        source = 'kickstart.sys tools/mkbootimg/images.sh tools/mkbootimg/menu.lst.cd tools/mkbootimg/menu.lst.fd0',
        target = 'metta.fd0 metta.iso',
        rule = './images.sh',
        cwd = bld.path.find_dir('tools/mkbootimg').abspath(),
        after = 'cxx_link' #initfs.img
    )

# kate: indent-width 4; replace-tabs on;
# vim: set et sw=4 ts=4 sts=4 cino=(4 :
