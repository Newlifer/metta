VERSION = os.popen("git show --oneline | head -n 1 | cut -d' ' -f1").read().strip()

#===================================
# Set up some global vars for build
#===================================

include_dirs = 'kernel kernel/generic nucleus nucleus/x86 runtime'.split()

stl_include_dirs = ['runtime', 'runtime/libc'] #'runtime/libc++/include',

# clang_debug_flag = ['-###']
clang_debug_flag = ['-v', '--trace-includes']

def configure(conf):
    # Define categories for building:
    # * Base template environment. (ENV)
    # * Kernel and bootstrap, with no external dependencies. (KERNEL_ENV)
    # * Apps/servers running on target system, with possible kernel/boot deps. (APP_ENV)
    # * Tools running on host system, stl/boost ok. (TOOLS_ENV)
    # * Tests running on host system, using boost_unit_test_framework. (TEST_ENV)
    # * Tests running on the target system (KERNEL_TEST_ENV)

    conf.load('yasm meddle genpaths', tooldir='waftools')

    system_header_dir = map(lambda d: '-isystem' + d, [os.getcwd()+'/runtime/libc++/include', clang_tc_dir(tc_dir, 'lib/clang/3.2/include')])

    # Set up common environment variables
    conf.env.append_unique('YASM_FLAGS', ['-f', 'elf'])

    conf.env.append_unique('INCLUDE_DIRS', include_dirs)
    conf.env.append_unique('INCLUDE_DIRS', 'interfaces')
    conf.env.append_unique('INCLUDE_DIRS', 'interfaces/nemesis')
    # Set arch-specific include paths
    conf.env.append_unique('INCLUDE_DIRS', map(lambda d: d + arch, 'kernel/arch/'.split()))
    conf.env.append_unique('INCLUDE_DIRS', map(lambda d: d + platform, 'kernel/platform/'.split()))
    # Append shared includes after, so we could override in arch-specific ones.
    conf.env.append_unique('INCLUDE_DIRS', 'kernel/arch/shared kernel/platform/shared'.split())

    # Config for building kernel
    conf.setenv('KERNEL_ENV', env_base)
    conf.env.append_unique('INCLUDE_DIRS', stl_include_dirs)
    conf.env.append_unique('CCFLAGS', extra_cross_flags + kernel_flags + system_header_dir)
    conf.env.append_unique('CXXFLAGS', extra_cross_flags + extra_cross_cxxflags + system_header_dir)
    conf.env.append_value('LINKFLAGS',  linkflags + kernel_linkflags)

    if sys.platform == 'darwin': conf.env.LIB_OPENSSL = 'crypto'
    else: conf.env.LIB_OPENSSL = 'ssl'

def build(bld):
    tc_dir = toolchain_path()

    arch = Options.options.arch
    platform = Options.options.platform

    # Make bootimage components.
    bld.all_comp_targets = []
    bld.recurse("modules")

    # Common libraries
    # TODO: add conditional source compilation: if arch/<cpu>/runtime/ directory has optimized versions, use them.
    libdebug = bld.stlib(
        source = map(lambda d: "kernel/arch/"+arch+"/"+d, 'panic.cpp debugger.cpp registers.s'.split()),
        target = 'debug',
        env = bld.all_envs['KERNEL_ENV'].derive()
    )
    libdebug.includes = libdebug.env.INCLUDE_DIRS

    commons = bld.stlib(
        source = map(lambda d: 'kernel/generic/'+d+'.cpp', 'elf_parser console module_loader'.split()),
        target = 'common',
        env = bld.all_envs['KERNEL_ENV'].derive()
    )
    commons.includes = commons.env.INCLUDE_DIRS

    bld.recurse('kernel/platform/'+Options.options.platform)

    libkernel = bld.stlib(
        source = map(lambda d: 'kernel/arch/'+arch+'/' + d, 'bootinfo.cpp bootimage.cpp'.split()) + ['kernel/arch/shared/bootinfo.cpp'],
        target = 'kernel',
        env = bld.all_envs['KERNEL_ENV'].derive()
    )
    libkernel.includes = libkernel.env.INCLUDE_DIRS

    ################################
    # FINAL OUTPUTS
    ################################

    if platform != 'hosted':
        # Initial loader.
        # Initial loader provides boot sequence abstraction for the kernel.
        # It may also choose which kernel to boot depending on the environment.

        ################################################################################################
        # Launcher.
        #
        # Launcher sets up a necessary environment (for example device trees),
        # pulls a necessary version of the nucleus from the boot image, initializes it,
        # pulls a right copy of root domain from the boot image and passes control to it, switching to ring3 along the way.
        # The privileged execution ends with the launcher and the nucleus.
        # The rest of the loading is done by the root domain.
        ################################################################################################

        launcher = bld.program(
            target = 'launcher.sys',
            source = map(lambda f: 'launcher/pc99/' + f, 'loader.s loader-ia32.cpp loader-multiboot.cpp multiboot-ia32.cpp'.split())
                + ['launcher/loader.cpp', 'modules/tcb/root_domain/root_domain.cpp', 'launcher/x86/startup.cpp']
                + map(lambda f: 'kernel/arch/x86/' + f, 'bootinfo.cpp continuation.s'.split()),
            use = 'interfaces common platform kernel runtime debug cxx',
            env = bld.all_envs['KERNEL_ENV'].derive()
        )
        launcher.env.append_unique('LINKFLAGS', ['-Wl,-T,../launcher/pc99/launcher.lds', '-Wl,-Map,launcher.map'])
        launcher.includes = launcher.env.INCLUDE_DIRS + ['launcher', 'launcher/pc99', 'modules/tcb/root_domain']

        ################################################################################################
        # Nucleus.
        #
        # Privileged mode ring0 nucleus.
        # Nucleus is the only ring0 privileged part of the system.
        # It includes interrupt handlers and some minimal syscall processing.
        ################################################################################################

        nucleus = bld.program(
            target = 'nucleus.sys',
            source = map(lambda f: 'nucleus/x86/' + f, 'idt.cpp isr.cpp interrupt.s init_nucleus.cpp nucleus.cpp'.split()),
            use = 'common kernel minruntime platform debug',
            env = bld.all_envs['KERNEL_ENV'].derive()
        )
        nucleus.env.append_unique('LINKFLAGS', ['-r']) # nucleus is relocatable.
        nucleus.env.append_unique('LINKFLAGS', ['-Wl,-T,../nucleus/x86/nucleus.lds', '-Wl,-Map,nucleus.map'])
        nucleus.gen_incpaths('')

        bld.undef_check(launcher.target)
        bld.undef_check(nucleus.target)

    #Check and add all output modules.
    nm = []
    for tg in bld.all_comp_targets:
        nm.append(tg)
    nm.append(nucleus.target)

    bld(
        source = ['buildboot', 'kernel/platform/'+Options.options.platform+'/bootimage.lst', 'interface_repository'] + nm,
        target = 'init.img',
        rule = '${SRC[0].abspath()} ./ ${SRC[1].abspath()} ${TGT}',
        name = 'init.img',
        depends_on = 'buildboot'
    )

    bld(
        source = 'launcher.sys init.img tools/mkbootimg/images.sh tools/mkbootimg/menu.lst.cd',
        target = 'metta.iso',
        rule = './images.sh',
        cwd = bld.path.find_dir('tools/mkbootimg').abspath(),
        after = 'init.img'
    )
