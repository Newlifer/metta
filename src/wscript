#!/usr/bin/env python
# -*- coding: utf-8 -*-

import os, sys, Task, Options, Configure, Utils, misc
Configure.autoconfig = 1

# FIXME: Could use bzr python modules, too.
VERSION = os.popen("bzr version-info|grep revno|cut -d' ' -f2").read().strip()
APPNAME = 'metta'

srcdir = '.'
blddir = '_build_'

include_dirs = 'kernel kernel/generic runtime'.split()

# Local SGI STL instance.
stl_defines = '_NOTHREADS __STL_NO_EXCEPTION_HEADER __STL_NO_BAD_ALLOC __STL_NO_DRAND48'.split()
stl_include_dirs = ['runtime/stl']

cflags = ['-fvisibility-inlines-hidden',  '-fvisibility=hidden']
flags = '-O0 -g -ffunction-sections -fdata-sections -pipe -Wall -Wextra -Werror'.split()
non_debug_flags = '-ffunction-sections -fdata-sections' # these make debugging harder
flags += ['-Wno-unused-variable', '-Wno-unused-parameter']

# Lion has deprecated some OpenSSL stuff we use.
flags += ['-Wno-deprecated-declarations']

# Change default waf behaviour wrt extensions.
def change_ext(self, ext):
    return self.parent.find_or_declare([self.name + ext])
import Node
Node.Node.change_ext = change_ext

def set_options(opt):
    # platform spec "arch-vendor-os", vendor can be omitted.
    # i686-exquance-metta
    # arm-metta

    opt.tool_options('module_template', tooldir='waftools')
    opt.tool_options('compiler_cc compiler_cxx')

    # arch (x86, x86-64, ppc, ppc64) - a generic cpu architecture (isa)
    # cpu (p4, arm11jsf) - a specific cpu format
    opt.add_option("--arch", action="store", default="x86", help="Select architecture to build for." + '[default: %default]')

    # platform (efi, pc99) - a generic infrastructure
    # board (vulcan, beagleboard) - a specific infrastructure
    opt.add_option("--platform", action="store", default="pc99", help="Select platform to build for." + '[default: %default]')

    # board usually implies platform, cpu and arch.
    # platform sometimes implies arch.

    # build type - release, debug, profile
    opt.add_option("--build", action="store", default="release", help="Select build type (release/debug/profile/all)." + '[default: %default]')

    # Use clang
    opt.add_option("--clang", action="store", default="no", help="Use clang to build (default: %default)")

def configure(conf):
    global flags, cflags, cxxflags, include_dirs, linkflags
    # Configure for given platform
    # Configuration name is composed of architecture, cpu, release
    arch = Options.options.arch
    platform = Options.options.platform
    build = Options.options.build
    clang = Options.options.clang == 'yes'

    # Define categories for building:
    # * Base template environment. (ENV)
    # * Kernel and bootstrap, with no external dependencies. (KERNEL_ENV)
    # * Apps/servers running on target system, with possible kernel/boot deps. (APP_ENV)
    # * Tools running on host system, stl/boost ok. (TOOLS_ENV)
    # * Tests running on host system, using boost_unit_test_framework. (TEST_ENV)
    # * Tests running on the target system (KERNEL_TEST_ENV)

    extra_cross_flags = ['-fno-builtin', '-fno-stack-protector'] #, '-fno-leading-underscore']

    conf.check_tool('yasm misc ar if2code', tooldir='waftools')

    conf.find_program('nm',var='NM')

    # TODO: try to use yasm, but allow fallback to NASM
    if clang:
        conf.check_tool('clang', tooldir='waftools') # FIXME: gcc detection per-config for x-compile?
        extra_cross_flags += ['-ccc-host-triple', 'i686-pc-linux-gnu']
#        extra_cross_flags += ['-###']
        extra_cross_cxxflags = ['-std=c++0x']
        linkflags = '-nostdlib'.split()
    else:
        conf.check_tool('compiler_cc compiler_cxx', tooldir='waftools') # FIXME: gcc detection per-config for x-compile?
        extra_cross_cxxflags = ['-std=gnu++0x']
        linkflags = '-nostdlib -nostartfiles -nodefaultlibs'.split()
        linkflags += ['--gc-sections', '--print-gc-sections']
        linkflags += ['-Wl,-O1', '-Wl,-zdynsort'] # GNU linker optimization of hash buckets.

    cxxflags = cflags

    # Set up common environment variables
    conf.env.append_unique('CCFLAGS', cflags + flags)
    conf.env.append_unique('CXXFLAGS', cxxflags + flags)
    conf.env.append_unique('YASM_FLAGS', ['-f', 'elf'])
    conf.env.append_unique('NASM_FLAGS', ['-f', 'elf'])

    conf.env['variant'] = arch + '-' + platform + '-' + build

    # Base template env
    conf.env.set_variant(conf.env['variant'])
    conf.set_env_name('ENV', conf.env)
    conf.setenv('ENV') # Activate the environment
    conf.env.append_unique('INCLUDE_DIRS', include_dirs)
    conf.env.append_unique('INCLUDE_DIRS', 'interfaces')
    # Set arch-specific include paths
    conf.env.append_unique('INCLUDE_DIRS', map(lambda d: d + arch, 'kernel/arch/'.split()))
    conf.env.append_unique('INCLUDE_DIRS', map(lambda d: d + platform, 'kernel/platform/'.split()))

    # Generate config.h
    # *_V options generate huge amount of output, beware.
    conf.define('ARCH', arch)
    conf.define('PLATFORM', platform)
    conf.define('BUILD', build)
    conf.define('CONFIG_INLINING', 1)
    conf.define('CONFIG_DEBUG_SYMBOLS', 1)
    conf.define('HEAP_DEBUG', 1)
    conf.define('MEMORY_DEBUG', 1)
    conf.define('ELF_LOADER_DEBUG', 0)
    conf.define('ELF_RELOC_DEBUG_V', 0)
    conf.define('BOOTIMAGE_DEBUG', 0)
    conf.define('DWARF_DEBUG', 0)
    conf.define('RAMTAB_DEBUG', 0)
    conf.define('TOOLS_DEBUG', 1) # Overarching tools debugging enabler, disable to turn off all tools debugging prints.
    conf.define('MEDDLER_DEBUG', 1) # Per-tool: Enable Meddler debug prints. Needs TOOLS_DEBUG.
    conf.define('CONFIG_COMPORT', 0)
    conf.define('CONFIG_COMSPEED', 115200)
    conf.define('CONFIG_X86_PSE', 1)
    conf.define('CONFIG_X86_PGE', 1)
    conf.define('CONFIG_X86_FXSR', 1)
    conf.define('CONFIG_X86_SYSENTER', 1)
    conf.define('CONFIG_IOAPIC', 1)
    conf.write_config_header('kernel/config.h')

    # Copy template env to specific ones
    conf.set_env_name('KERNEL_ENV', conf.env.copy())
    conf.set_env_name('APP_ENV', conf.env.copy())
    conf.set_env_name('TOOLS_ENV', conf.env.copy())
    conf.set_env_name('TEST_ENV', conf.env.copy())

    # Config for running tests
    conf.setenv('TEST_ENV')
    conf.env.append_unique('CXXFLAGS', ['-fexceptions'])
    conf.env.append_unique('CXXDEFINES', ['UNIT_TESTS'])
    conf.env['LIB_TEST'] = 'boost_unit_test_framework' # set uselib

    # Flag that we're building under/for Metta.
    # Value is metta release number, monotonically increasing with each public release.
    metta_flag = "__Metta__=1"
    kernel_flags = '-fno-strict-aliasing'.split() #-ffreestanding -nostdinc
    # --gc-sections ruins everything
    kernel_linkflags = [] #'-ffreestanding'.split() # -Wl,--gc-sections -Wl,--print-gc-sections

    # Config for building kernel
    conf.setenv('KERNEL_ENV')
    conf.env.append_unique('INCLUDE_DIRS', stl_include_dirs)
    conf.env.append_unique('CDEFINES', metta_flag)
    conf.env.append_unique('CXXDEFINES', metta_flag)
    conf.env.append_unique('CXXDEFINES', ['BOCHS_IO_HACKS']) # debugging hacks for bochs
    conf.env.append_unique('CXXDEFINES', stl_defines)
    conf.env.append_unique('CCFLAGS', extra_cross_flags + kernel_flags)
    conf.env.append_unique('CXXFLAGS', extra_cross_flags + extra_cross_cxxflags)
    conf.env.append_unique('CXXFLAGS', kernel_flags)
    conf.env.append_unique('CXXFLAGS', '-fno-rtti -fno-exceptions'.split())
    conf.env.append_unique('LINKFLAGS', kernel_linkflags + linkflags)
    if os.environ.has_key('CROSS_CC'):
        conf.env['CC'] = os.environ['CROSS_CC']
        conf.env['LINK_CC'] = os.environ['CROSS_CC']
    if os.environ.has_key('CROSS_CXX'):
        conf.env['CXX'] = os.environ['CROSS_CXX']
        conf.env['LINK_CXX'] = os.environ['CROSS_CXX']
    conf.env.append_unique('CCFLAGS', ['-m32'])
    conf.env.append_unique('CXXFLAGS', ['-m32'])
    conf.env.append_unique('LINKFLAGS', ['-m32'])

    # Config for building system apps
    conf.setenv('APP_ENV')
    conf.env.append_unique('INCLUDE_DIRS', stl_include_dirs)
    conf.env.append_unique('CDEFINES', metta_flag)
    conf.env.append_unique('CXXDEFINES', metta_flag)
    conf.env.append_unique('CXXDEFINES', ['BOCHS_IO_HACKS']) # debugging hacks for bochs
    conf.env.append_unique('CXXDEFINES', stl_defines)
    conf.env.append_unique('CCFLAGS', extra_cross_flags + kernel_flags)
    conf.env.append_unique('CXXFLAGS', extra_cross_flags + extra_cross_cxxflags)
    conf.env.append_unique('CXXFLAGS', kernel_flags)
    conf.env.append_unique('LINKFLAGS', kernel_linkflags + linkflags)

    # Use host cc for building tools and local tests - do we need target tests as well?
    conf.setenv('TOOLS_ENV')
    conf.env.append_unique('CXXFLAGS', extra_cross_cxxflags)
    if os.environ.has_key('HOST_CC'):
        conf.env['CC'] = os.environ['HOST_CC']
        conf.env['LINK_CC'] = os.environ['HOST_CC']
    if os.environ.has_key('HOST_CXX'):
        conf.env['CXX'] = os.environ['HOST_CXX']
        conf.env['LINK_CXX'] = os.environ['HOST_CXX']

    # set uselib
    conf.env.LIB_UUID = 'uuid'

    if sys.platform == 'darwin':
        conf.env.LIB_OPENSSL = 'crypto'
    else:
        conf.env.LIB_OPENSSL = 'ssl'

    conf.env.LIBPATH_LLVM = '/Users/berkus/Tools/lib/'
    conf.env.STATICLIB_LLVM = ['LLVMSupport', 'LLVMSystem']
    conf.env.LIB_LLVM = 'pthread'

    # conf.env.SOMEVAR = Utils.h_file('meddler')

    #conf.setenv('TEST_ENV')
    #conf.env['CC'] = '/Developer/usr/bin/gcc'
    #conf.env['CXX'] = '/Developer/usr/bin/g++'
    #conf.env['LINK_CC'] = '/Developer/usr/bin/gcc'
    #conf.env['LINK_CXX'] = '/Developer/usr/bin/g++'
    #conf.env.append_unique('CCFLAGS', ['-m32'])
    #conf.env.append_unique('CXXFLAGS', ['-m32'])
    #conf.env.append_unique('LINKFLAGS', ['-m32'])

def build(bld):
    arch = Options.options.arch

    # Tool to parse interface files.
    # Build it first so that we can transform interface defitions to code during build.
    meddler = bld.new_task_gen('cxx', 'program')
    meddler.name = 'meddler'
    meddler.target = 'meddler'
    meddler.source = map(lambda f: 'tools/meddler/' + f + '.cpp', 'meddler parser lexer ast symbol_table emit_cpp'.split())
    meddler.env = bld.env_of_name('TOOLS_ENV').copy()
    meddler.env.append_unique('CXXDEFINES', ['__STDC_LIMIT_MACROS', '__STDC_CONSTANT_MACROS'])
    meddler.includes = meddler.env['INCLUDE_DIRS'] + ['tools/meddler']
    meddler.uselib = 'LLVM'

    meddler.post()
    bld.add_group()

    bld.add_subdirs("tools/mettafs")

    # List interfaces sorted alphabetically.
    interface_files = ['activation_v1', 'channel_v1', 'closure', 'domain_v1', 'event_v1', 'fault_handler_v1', 'frame_allocator_v1', 
                       'frames_module_v1', 'heap_module_v1', 'heap_v1', 'map_card64_address_v1', 'map_card64_address_factory_v1', 
                       'map_string_address_v1', 'map_string_address_factory_v1', 'memory_v1', 'mmu_module_v1', 'mmu_v1', 
                       'naming_context_v1', 'pervasives_v1', 'protection_domain_v1', 'ramtab_v1', 'stretch_allocator_module_v1',
                       'stretch_allocator_v1', 'stretch_driver_module_v1', 'stretch_driver_v1', 'stretch_table_v1', 'stretch_table_module_v1', 
                       'stretch_v1', 'system_frame_allocator_v1', 'system_stretch_allocator_v1', 'time_v1', 'timer_v1', 'types', 
                       'type_system_v1', 'type_system_f_v1', 'type_system_factory_v1', 'vcpu_v1',
                       # Temporary interfaces "borrowed" from Nemesis
                       'nemesis/exception_v1', 'nemesis/exception_support_v1', 'nemesis/exception_support_setjmp_v1', 'nemesis/exception_system_v1']

    # Now generate interface files.
    ifbld = bld(
        source = map(lambda d: 'interfaces/'+d+'.if', interface_files), 
        name = 'all_idl', # This name is used by components to express dependency.
        after = 'meddler'
    )
    ifbld.env.append_unique('IDL_INC', ['../interfaces', '../interfaces/nemesis']) # TODO: make if2code produce relative paths properly!!
    # bld.add_manual_dependency('meddler', 'all_idl')
    # bld.add_manual_dependency('all_idl', 'meddler')

    # Make bootimage components.
    bld.setup_module_build = setup_module_build
    bld.add_subdirs("modules")

    # Common libraries
    # TODO: add conditional source compilation: if arch/<cpu>/runtime/ directory has optimized versions, use them.
    runtime = bld.new_task_gen('cxx', 'staticlib')
    runtime.source = map(lambda d: 'runtime/' + d + '.cpp', 'g++support memutils cstring stdlib newdelete'.split())
    runtime.env = bld.env_of_name('KERNEL_ENV').copy()
    runtime.includes = runtime.env['INCLUDE_DIRS']
    runtime.target = 'runtime'

    minruntime = bld.new_task_gen('cxx', 'staticlib')
    minruntime.source = map(lambda d: 'runtime/' + d + '.cpp', 'g++support dummy_delete memutils cstring'.split())
    minruntime.env = bld.env_of_name('KERNEL_ENV').copy()
    minruntime.includes = minruntime.env['INCLUDE_DIRS']
    minruntime.target = 'minruntime'

    toolruntime = bld.new_task_gen('cxx', 'staticlib')
    toolruntime.source = 'runtime/memutils.cpp runtime/cstring.cpp'.split()
    toolruntime.env = bld.env_of_name('TOOLS_ENV').copy()
    toolruntime.includes = include_dirs
    toolruntime.target = 'toolruntime'

    commons = bld.new_task_gen('cxx', 'staticlib')
    commons.source = map(lambda d: 'kernel/generic/'+d+'.cpp', 'elf_parser console module_loader'.split())
    commons.env = bld.env_of_name('KERNEL_ENV').copy()
    commons.includes = commons.env['INCLUDE_DIRS']
    commons.target = 'common'

    platform = bld.new_task_gen('cxx', 'staticlib')
    platform.source = map(lambda d: "kernel/platform/" + Options.options.platform + "/" + d, 'multiboot.cpp default_console.cpp'.split()) + map(lambda d: "kernel/arch/"+arch+"/"+d, 'panic.cpp debugger.cpp registers.s'.split())
    platform.env = bld.env_of_name('KERNEL_ENV').copy()
    platform.includes = platform.env['INCLUDE_DIRS']
    platform.target = 'platform'

    libkernel = bld.new_task_gen('cxx', 'staticlib')
    libkernel.source = map(lambda d: 'kernel/arch/'+arch+'/' + d, 'bootinfo.cpp bootimage.cpp'.split())#cpu.cpp  + ['kernel/generic/stretch_driver.cpp'] # TODO: This should be in arch/x86/ too. x86_frame_allocator.cpp x86_protection_domain.cpp
    libkernel.env = bld.env_of_name('KERNEL_ENV').copy()
    libkernel.includes = libkernel.env['INCLUDE_DIRS']
    libkernel.target = 'kernel'

    interfaces = bld.new_task_gen('cxx', 'staticlib')
    interfaces.source = map(lambda d: 'interfaces/' + d + '_interface.cpp', interface_files)
    interfaces.env = bld.env_of_name('KERNEL_ENV').copy()
    interfaces.includes = interfaces.env['INCLUDE_DIRS']
    interfaces.target = 'interfaces'

    # Tests
#    tests = bld.new_task_gen('cxx', 'program')
#    tests.source = 'tests/test_suite_main.cpp'.split()# tests/test_rbtree.cpp
#    tests.env = bld.env_of_name('TEST_ENV').copy()
#    tests.includes = tests.env['INCLUDE_DIRS']
#    tests.uselib = 'TEST'
#    tests.target = 'testrunner'

    slebtest = bld.new_task_gen('cxx', 'program')
    slebtest.source = 'tests/slebtest.cpp'
    slebtest.env = bld.env_of_name('TEST_ENV').copy()
    slebtest.includes = slebtest.env['INCLUDE_DIRS']
    slebtest.target = 'slebtest'
    #slebtest.uselib_local = 'toolruntime common'

    #parsedwarf = bld.new_task_gen('cxx', 'program')
    #parsedwarf.source = map(lambda f: 'tools/parsedwarf/'+f+'.cpp', 'parsedwarf form_reader datarepr dwarf_info dwarf_parser dwarf_aranges dwarf_abbrev dwarf_lines'.split())
    #parsedwarf.env = bld.env_of_name('TOOLS_ENV').copy()
    #parsedwarf.includes = parsedwarf.env['INCLUDE_DIRS']
    #parsedwarf.target = 'parsedwarf'
    #parsedwarf.uselib_local = 'toolruntime common'

    # Tool to build bootimage.
    buildboot = bld.new_task_gen('cxx', 'program')
    buildboot.target = 'buildboot'
    buildboot.source = 'tools/buildboot/buildboot.cpp'
    buildboot.env = bld.env_of_name('TOOLS_ENV').copy()
    buildboot.env.append_unique('CXXFLAGS', ['-fexceptions'])
    buildboot.env.append_unique('LINKFLAGS', '-lstdc++') # hm, why is this needed?
    buildboot.includes = buildboot.env['INCLUDE_DIRS']

    # Initial loader
    kickstart = bld.new_task_gen('cxx', 'program')
    kickstart.target = 'kickstart.sys'
    kickstart.source = map(lambda f: 'kernel/platform/pc99/' + f, 'loader.s loader-ia32.cpp loader-multiboot.cpp multiboot-ia32.cpp'.split()) + ['kernel/generic/loader.cpp', 'kernel/arch/x86/bootinfo.cpp']
    kickstart.env = bld.env_of_name('KERNEL_ENV').copy()
    kickstart.env.append_unique('LINKFLAGS', ['-Wl,-T,../kernel/platform/pc99/loader.lds', '-Wl,-Map,kickstart.map'])
    kickstart.includes = kickstart.env['INCLUDE_DIRS']
    kickstart.uselib_local = 'common platform minruntime'# kernel

    # Launcher
    # FIXME: ld doesn't report unresolved symbols for -r apps? WTF
    # TODO: post-process linked modules with symbol checker
    # TODO: put elf manipulation code to libgaladriel
    startup = bld.new_task_gen('cxx', 'program')
    startup.target = 'kernel-startup.sys'
    startup.source = map(lambda f: 'kernel/arch/x86/' + f, 'startup.s startup.cpp idt.cpp interrupt.s isr.cpp pit.cpp continuation.s'.split()) + map(lambda f: 'modules/root_domain/' + f, ['root_domain.cpp']) + ['interfaces/timer_v1_interface.cpp']
    startup.env = bld.env_of_name('KERNEL_ENV').copy()
    startup.env.append_unique('LINKFLAGS', ['-r']) # Kernel startup is relocatable.
    startup.env.append_unique('LINKFLAGS', ['-Wl,-T,../kernel/arch/x86/startup.lds', '-Wl,-Map,startup.map'])
    startup.includes = startup.env['INCLUDE_DIRS'] + ['modules/root_domain']
    startup.uselib_local = 'common platform kernel minruntime'# interfaces

    # Glue code
    # Glue code is the only ring0 privileged part of the system.
    # It includes interrupt handlers and some minimal syscall processing.

    # TODO: add nucleus_* code here, initialize glue before kernel startup??
    glue = bld.new_task_gen('cxx', 'program')
    glue.target = 'glue.sys'
    glue.source = map(lambda f: 'kernel/arch/x86/' + f, 'idt.cpp interrupt.s isr.cpp pit.cpp continuation.s'.split())
    glue.env = bld.env_of_name('KERNEL_ENV').copy()
    glue.env.append_unique('LINKFLAGS', ['-r']) # glue is relocatable.
    glue.env.append_unique('LINKFLAGS', ['-Wl,-T,../kernel/arch/x86/startup.lds', '-Wl,-Map,glue.map'])
    glue.includes = glue.env['INCLUDE_DIRS']
    glue.uselib_local = 'common kernel minruntime platform'

    #kickstart = bld.new_task_gen('cxx', 'program')
    #kickstart.source = map(lambda f: 'kernel/arch/' + arch + '/' + f, 'kickstart.cpp isr.cpp idt.cpp interrupt.s'.split()) + ['kernel/platform/pc99/loader.s']
    ## isr.cpp interrupt.s initfs.cpp c++boot.cpp kickstart.lds
    #kickstart.env = bld.env_of_name('KERNEL_ENV').copy()
    #kickstart.env.append_unique('LINKFLAGS', ['-T', '../kernel/arch/'+arch+'/kickstart.lds', '-Wl,-Map,kickstart.map'])
    #kickstart.includes = kickstart.env['INCLUDE_DIRS']
    #kickstart.target = 'kickstart.sys'
    #kickstart.uselib_local = 'platform common kernel runtime'

    undef_check(bld, 'kernel-startup.sys')
    undef_check(bld, 'glue.sys')

    #Check and add all output modules.
    nm = []
    for tg in bld.all_task_gen:
        if tg.target.endswith('.comp'):
            #print "posting "+tg.target
            tg.post()
            nm.append(tg.link_task.outputs[0].relpath_gen(bld.path))

    bld.new_task_gen(
        source = 'buildboot kernel/arch/x86/bootimage.lst'.split() + nm, # x86 arch dep
        target = 'init.img',
        rule = '${SRC[0].abspath(env)} x86-pc99-release/ ${SRC[1].abspath(env)} ${TGT}',
        name = 'init.img',
        after = 'cxx_link'
    )

    bld.new_task_gen('subst',
        source = 'tools/mkbootimg/menu.lst.in',
        target = 'tools/mkbootimg/menu.lst.cd',
        dict = {'ROOT': 'cd'}
    )

    bld.new_task_gen(
        source = 'kickstart.sys kernel-startup.sys init.img tools/mkbootimg/images.sh tools/mkbootimg/menu.lst.cd',
        target = 'metta.iso',
        rule = './images.sh',
        cwd = bld.path.find_dir('tools/mkbootimg').abspath(),
        after = 'init.img'
    )

# kate: indent-width 4; replace-tabs on;
# vim: set et sw=4 ts=4 sts=4 cino=(4 :
