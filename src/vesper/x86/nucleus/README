Nucleus is the minimalistic core of an microkernel system.

This nucleus provides very low-level services to client applications using syscalls.

This nucleus has two ways of providing the syscall interface: one is by including arch-specific
syscalls.h file and using *_syscall ABI family of functions. These are architecture specific and try to
perform in the fastest way possible.
Another way is to grab kernel interface page location using kernel_interface_syscall and then by calling code
specified in special table in the interface page. This code tries to minimize amount of context switches and does
as much as possible in userspace, calling specialized syscalls when needed.

Classes of syscalls provided by this nucleus are:
 * thread control
 * protection domain control
 * fast cross-pd IPC


Thread control

Migrating threads mean there are multiple threads can be executing inside a single space (or object). This means there should be
ways to efficiently lock parts of shared state of the object when multiple objects are trying to access it. Well-placed fine-grained
locks and fast lock/unlock primitives are needed.

A thread can create other threads, suspend/resume them, examine their state, donate own CPU time to these threads. This implies
a) security checks on whether thread possesses privileges to do certain operations, b) some sort of parent-child relationship between
threads.

A thread may be in multiple address spaces at once, however, only one instance is active and all other a suspended in a "continuation".


PD control




IPC

Atomic IPC - no state is maintained within the kernel about the running IPC operation. Thread continuations may be manipulated to "restart"
and IPC transaction.

Atomic kernel API means there is no shared state to modify and syscalls can run without taking locks all the time.



