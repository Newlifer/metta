Portal manager provides ways for separate components to establish communication between each other.

Portal manager allows a client to build connection to call on a server to perform various duties.
Since portal traversal does not invoke scheduler, it is seen as a simple cross-protection-domain
function call.
However, portal manager allows for task-specific optimizations, for example a getpid() call can be optimized
to never cross protection domain boundaries.
Also, it is portal manager's responsibility to ensure correct and safe protection domain change.
Therefore portal manager is part of TCB (trusted computing base) application set.

Portal is a memory location, accessible by calling process ("the client"), that contains code to perform
pre-jump initialization, if necessary, protection domain change, call into target component and then return handling.
This code is very sensitive in a sense, that if it was directly accessible to the client for inspection and/or modification, a malicious client would be able to obtain valid code from portal manager, manipulate it to perform undesired actions and then execute as if it was a normal portal generated by the portal manager.

a) To invoke portal code executes a trap instruction.
b) trapping into the nucleus -> nucleus determines portal to use and calls it
c)

call some server function -> indirect call through portal table indexed w/ some index.
code in portal table traps into the nucleus, specifying portal code to execute.
portal code sets up mappings, parameter marshalling etc. and jumps to server code.


portal manager privileged portion generates portal_table and stub code

------------------

Servers provide interfaces to them as binary descriptors much like Qt's signal/slot description data, generated from the interface IDL.

Portal manager can derive information necessary to build a portal from these descriptions.

Clients request server interfaces by interface name or interface plus method name.

 * client has to use trader interface to find appropriate component
 * then a call to portal manager is made to instantiate interface to selected component
 * specified version of the interface is used to build portal table entries
 * portal manager verifies permissions and builds stub code
   * stub code may return errors for non-permitted calls e.g.


Start with: simple server idl, simple portal mgr that can read this idl in compiled form.

interface definition: COM-like interfaces,
java package notation instead of guids (?),
objects created by factories (COM-style).
needs to support reflexion and introspection of implemented interfaces.
needs to support versioning and easy access to multiple versions of the implementation.
using trader (broker) to find and instantiate components or factories. (?)

// Trader is used to register and find objects.
// Registration and querying interfaces are separated because clients might not even use
// registration functionality.
interface com_itrader
{
    status_t query(const_string interface_spec, const_string constraint_spec, list<com_iunknown*> results);
    status_t lookup(const_string interface_spec, list<com_iunknown*> results);
    uint32_t ref(com_iunknown* obj);
    uint32_t unref(com_iunknown* obj);
};

interface com_itrader_registrar
{
    status_t register(const_string interface_spec, com_iunknown* obj);
    status_t unregister(const_string interface_spec, com_iunknown* obj);
    uint32_t ref(com_iunknown* obj);
    uint32_t unref(com_iunknown* obj);
};

On startup components receives reference to its Parent interface, through which
it can explore and query all other available interfaces.
