//
// Part of Metta OS. Check http://metta.exquance.com for latest version.
//
// Copyright 2007 - 2012, Stanislav Karchebnyy <berkus@exquance.com>
//
// Distributed under the Boost Software License, Version 1.0.
// (See file LICENSE_1_0.txt or a copy at http://www.boost.org/LICENSE_1_0.txt)
//
#include "type_system_v1_interface.h"
#include "type_system_f_v1_interface.h"
#include "type_system_f_v1_impl.h"
#include "type_system_factory_v1_interface.h"
#include "type_system_factory_v1_impl.h"
#include "enum_v1_interface.h"
#include "record_v1_interface.h"
#include "operation_v1_interface.h"
#include "interface_v1_state.h"
#include "interface_v1_impl.h"
#include "map_card64_address_factory_v1_interface.h"
#include "map_string_address_factory_v1_interface.h"
#include "map_card64_address_v1_interface.h"
#include "map_string_address_v1_interface.h"
#include "heap_new.h"
#include "default_console.h"
#include "exceptions.h"
#include "debugger.h"

/**
 * @defgroup typecode Type code
 *
 * Type code is 64 bit entity consisting of 48-bit unique identifier for the interface type plus 16 bit entity for indexing subtypes inside the interface
 * (exceptions, aliases, structures, etc.)
 * 48 bit code is generated by meddler while parsing the interface file. It attempts to maintain some sort of stability for type codes for same interfaces.
 * 16 bit code is just a sequential enumeration of all types inside an interface.
 */

//=====================================================================================================================
// Type system internal data structures.
//=====================================================================================================================

struct type_system_f_v1::state_t
{
    type_system_f_v1::closure_t        closure;
    map_card64_address_v1::closure_t*  interfaces_by_typecode;
    map_string_address_v1::closure_t*  interfaces_by_name;
};

extern interface_v1::state_t meta_interface; // forward declaration

//=====================================================================================================================
// add, remove, dup and destroy methods from naming_context are all nulls.
//=====================================================================================================================

static void
shared_add(naming_context_v1::closure_t*, const char*, types::any)
{
    OS_RAISE((exception_support_v1::id)"naming_context_v1.denied", 0);
    return;
}

static void
shared_remove(naming_context_v1::closure_t*, const char*)
{ 
    OS_RAISE((exception_support_v1::id)"naming_context_v1.denied", 0);
    return; 
}

// dup is not yet defined, but it raises denied as well

static void
shared_destroy(naming_context_v1::closure_t*)
{ 
    return; 
}

//=====================================================================================================================
// Typesystem
//=====================================================================================================================

/**
 * Look up a type name in this interface.
 */
// static type_representation_t* internal_get(type_system_f_v1::state_t* state, cstring_t name)
// {
//     interface_v1::state_t* iface = nullptr;
//     type_representation_t* result = nullptr;
//     cstring_t extra;

//     // pos = find(name, '.');
//     // if (pos)
//     // {
//     //     extra = name[pos+1:];
//     //     name = name[:pos-1];
//     // }

//     /* now "name" is just the interface, and "extra" is any extra qualifier */

//     if (state->interfaces_by_name->get(name.c_str(), (address_t*)&iface))
//     {
//         /* We've found the first component. */
//         if (extra[0])
//         {
//             for (int i = 0; iface->types[i]; ++i)
//                 if (extra == iface->types[i]->name)
//                     result = iface->types[i];

//             /* special case if it's an intf type defined by the metainterface */
//             if (!result && (iface == &meta_interface))
//             {
//                 result = internal_get(state, extra);
//             }
//         }
//         else
//         {
//             /* Otherwise return this interface clp */
//             result = &iface->rep;
//         }
//     }

//     return result;
// }

/**
 *  Return a list of all types in the type system.
 */
static naming_context_v1::names
type_system_v1_list(naming_context_v1::closure_t* self)
{
    // TypeSystem_st           *st  = (TypeSystem_st *) self->st;
    // NOCLOBBER StringTblIter_clp iter = NULL;
    // Context_Names           *seq;

    // TRC(printf("TypeSystem$List: called\n"));
    
    // /* Get the result sequence */
    // seq = SEQ_CLEAR (SEQ_NEW (Context_Names, 4*StringTbl$Size (st->intfsByName),
    //               Pvs(heap)));

    // /* Run through all the interfaces */
    // TRY
    // {
    //     string_t        name;
    //     Intf_st        *tb;
    //     TypeRep_t         **trep ;

    //     iter = StringTbl$Iterate (st->intfsByName);

    //     while (StringTblIter$Next (iter, &name, (addr_t*)&tb))
    //     {
    //         AddName (tb->rep.name, Pvs(heap), seq);

    //         /* Run through all the types defined in the current interface */
    //         for (trep = (TypeRep_t **)tb->types; *trep; trep++)
    //         AddQualName ( (*trep)->name, tb->rep.name, Pvs(heap), seq);
    //     }
    //     StringTblIter$Dispose (iter);
    // }
    // CATCH_ALL {
    //       DB(printf("TypeSystem$List: failed in Malloc: undoing.\n"));
    //       if (iter) StringTblIter$Dispose (iter);
    //       SEQ_FREE_ELEMS (seq);
    //       SEQ_FREE (seq);
    //       DB(printf("TypeSystem$List: done undoing.\n"));
    //       RAISE_Heap$NoMemory();
    //       }
    // ENDTRY;

    // TRC(printf("TypeSystem$List: done.\n"));
    // return seq;
    return naming_context_v1::names();
}

/**
 * Type System Get method - return the type code as any.
 */ 
static bool
type_system_v1_get(naming_context_v1::closure_t* self, const char* name, types::any* obj)
{
    // TypeRep_t *tr = Int_Get ((TypeSystem_st *) self->st,  name);
  
    // if (!tr)
    // return False;

    // ANY_COPY (o, &(tr->code));
    // return True;
    return false;
}

/**
 * Info returns information about a type given its typecode.
 */
static interface_v1::closure_t*
type_system_v1_info(type_system_v1::closure_t* self, type_system_v1::alias tc, types::any* rep)
{
    // TypeSystem_st *st = (TypeSystem_st *) self->st;
    // Intf_st *b;
    // TypeRep_t   *tr;

    // /* Check the type code refers to a valid interface */
    // if (!LongCardTbl$Get (st->intfsByTC, TCODE_INTF_CODE (tc), (addr_t*)&b))
    // RAISE_TypeSystem$BadCode(tc);

    // /* Deal with the case where the type code refers to an interface type */
    // if (TCODE_IS_INTERFACE (tc)) 
    // {
    // ANY_COPY (rep, &(b->rep.any));
      
    // return (Interface_clp) &meta_cl;
    // }
  
    // /* Check that within the given interface this is a valid type */
    // if (! TCODE_VALID_TYPE (tc, b))
    // RAISE_TypeSystem$BadCode (tc);

    // tr = TCODE_WHICH_TYPE (tc, b);
  
    // ANY_COPY (rep, (Type_Any *)&tr->any);

    // return (Interface_clp) (word_t) (b->rep.any.val);
    return 0;
}

/**
 * Return the size of a type.
 */
static memory_v1::size
type_system_v1_size(type_system_v1::closure_t* self, type_system_v1::alias tc)
{
    interface_v1::state_t* iface = nullptr;

    /* Check the type code refers to a valid interface */
    if (!reinterpret_cast<type_system_f_v1::state_t*>(self->d_state)->interfaces_by_typecode->get(TCODE_INTF_CODE(tc), (address_t*)&iface))
        OS_RAISE((exception_support_v1::id)"type_system_v1.bad_code", tc);

    /* Deal with the case where the type code refers to an interface type */
    if (TCODE_IS_INTERFACE (tc))
        return iface->rep.size;
  
    /* Check that within the given interface this is a valid type */
    if (!TCODE_VALID_TYPE (tc, iface))
        OS_RAISE((exception_support_v1::id)"type_system_v1.bad_code", tc);

    return TCODE_WHICH_TYPE(tc, iface)->size;
}

static types::name
type_system_v1_name(type_system_v1::closure_t* self, type_system_v1::alias tc)
{
    interface_v1::state_t* iface = nullptr;

    /* Check the type code refers to a valid interface */
    if (!reinterpret_cast<type_system_f_v1::state_t*>(self->d_state)->interfaces_by_typecode->get(TCODE_INTF_CODE(tc), (address_t*)&iface))
        OS_RAISE((exception_support_v1::id)"type_system_v1.bad_code", tc);

    /* Deal with the case where the type code refers to an interface type */
    if (TCODE_IS_INTERFACE (tc))
    {
    // name = strdup(b->rep.name);
    // if(!name) RAISE_Heap$NoMemory();
    // return name;
    }
  
    /* Check that within the given interface this is a valid type */
    if (!TCODE_VALID_TYPE (tc, iface))
        OS_RAISE((exception_support_v1::id)"type_system_v1.bad_code", tc);

    type_representation_t* tr = TCODE_WHICH_TYPE(tc, iface);
    // name = strdup(tr->name);
    // if(!name) RAISE_Heap$NoMemory();
    // return name;
    return 0;
}

/**
 * Try to find out if two types are compatible.
 */
static bool
type_system_v1_is_type(type_system_v1::closure_t* self, type_system_v1::alias sub, type_system_v1::alias super)
{
    // TypeSystem_st *st = (TypeSystem_st *) self->st;
    // Intf_st *b;

    // /* Check the type code refers to a valid interface */
    // if (!LongCardTbl$Get (st->intfsByTC, 
    //           TCODE_INTF_CODE (super), 
    //           (addr_t*)&b)) {
    // eprintf("TypeSystem$IsType: unknown typecode (super=%lx)\n", super);
    // RAISE_TypeSystem$BadCode (super);
    // }

    // /* Quick and dirty check for equality */
    // if (sub == super) {
    // return True;
    // }

    // /* Check the type code refers to a valid interface */
    // if (!LongCardTbl$Get (st->intfsByTC, TCODE_INTF_CODE (sub), (addr_t*)&b)) {
    // eprintf("TypeSystem$IsType: unknown typecode (sub=%lx)\n", sub);
    // RAISE_TypeSystem$BadCode (sub);
    // }

    // /* Deal with the case where the type code refers to an interface type */
    // if (TCODE_IS_INTERFACE (sub)) 
    // {
    // while (b->rep.code.val != super) 
    // {
    //     /* Look up the supertype */
    //     if ( !b->extends ) {
    //     return False;
    //     }
    //     if (!LongCardTbl$Get (st->intfsByTC, b->extends, (addr_t*)&b)) {
    //     eprintf("TypeSystem$IsType: unknown typecode (super=%lx)\n", 
    //         b->extends);
    //     RAISE_TypeSystem$BadCode (sub);
    //     }
    // }
    // return True;
    // }

    // /* We have a concrete type and it's not the same typecode, so fail. */
    return false;
}

/**
 * Try to narrow a type.
 */
static types::val
type_system_v1_narrow(type_system_v1::closure_t* self, types::any a, type_system_v1::alias tc)
{
    // if (!Ts_IsType (self, a->type, tc)) {
    // NTRC(printf("TS$Narrow: any's type (%qx) incompat with desired %qx\n",
    //        a->type, tc));
    // RAISE_TypeSystem$Incompatible();
    // }
    
    // return a->val;
    return types::val();
}

/**
 * Unalias a type - recurse up alias chain until a non-alias type is found.
 */
static type_system_v1::alias
type_system_v1_unalias(type_system_v1::closure_t* self, type_system_v1::alias tc)
{
    // TypeSystem_st *st = (TypeSystem_st *) self->st;
    // Intf_st *b  = NULL;
    // TypeRep_t   *tr = NULL;

    // for(;;) {
    // /* Check the type code refers to a valid interface */
    // if (!LongCardTbl$Get (st->intfsByTC, TCODE_INTF_CODE (a), (addr_t*)&b))
    //     RAISE_TypeSystem$BadCode (a);
    
    // /* Deal with the case where the type code refers to an interface type */
    // if (TCODE_IS_INTERFACE (a))
    //     return a;
    
    //  Check that within the given interface this is a valid type 
    // if (! TCODE_VALID_TYPE (a, b))
    //     RAISE_TypeSystem$BadCode(a);
    
    // /* Get the representation of this type */
    // tr = TCODE_WHICH_TYPE (a, b); 

    // /* If it's not an alias, return it */
    // if ( tr->any.type != TypeSystem_Alias__code ) return a;
    
    // /* Else go round again. */
    // a = ((Type_Any *)&tr->any)->val;
    // }
    // RAISE_TypeSystem$BadCode (a);
    return type_system_v1::alias();
}

/*
 * Method suites for all type representation which include a closure.
 */ 
extern interface_v1::ops_t interface_ops;
extern operation_v1::ops_t operation_ops;
extern exception_v1::ops_t exception_ops;
extern record_v1::ops_t    record_ops;
extern enum_v1::ops_t      enum_ops;
// extern choice_v1::ops_t    choice_ops;

static void
type_system_f_v1_register_interface(type_system_f_v1::closure_t* self, type_system_f_v1::interface_info intf)
{
    interface_v1::state_t* iface = reinterpret_cast<interface_v1::state_t*>(intf); // @todo do we need to convert this back and forth?
    address_t dummy;

    kconsole << "register_interface '" << iface->rep.name << "' {" << endl;

    if (self->d_state->interfaces_by_name->get(iface->rep.name, &dummy))
        OS_RAISE((exception_support_v1::id)"type_system_f_v1.name_clash", 0);

    if (self->d_state->interfaces_by_typecode->get(iface->rep.code.value, &dummy))
        OS_RAISE((exception_support_v1::id)"type_system_f_v1.type_code_clash", 0);

    if (iface != &meta_interface) // meta_interface needs no patching, it's all set up.
    {
        address_t clos_ptr;
        size_t i;

        /* Fill in operation tables of closures */
        reinterpret_cast<interface_v1::closure_t*>(iface->rep.any.value)->d_methods = &interface_ops;

        /* Types */
        for (i = 0; i < iface->num_types; i++)
        {
            clos_ptr = iface->types[i]->any.value;
            switch (iface->types[i]->any.type_)
            {
                // case type_system_v1::choice_type_code:
                //     reinterpret_cast<choice_v1::closure_t*>(clos_ptr)->d_methods = &choice_ops;
                //     break;
                case type_system_v1::enum__type_code:
                    reinterpret_cast<enum_v1::closure_t*>(clos_ptr)->d_methods = &enum_ops;
                    break;
                case type_system_v1::record__type_code:
                    reinterpret_cast<record_v1::closure_t*>(clos_ptr)->d_methods = &record_ops;
                    break;
            }
        }

        /* Operations */
        for (i = 0; i < iface->num_methods; i++) {
            iface->methods[i]->closure->d_methods = &operation_ops;
        }

        /* Exceptions */
        for (i = 0; i < iface->num_exns; i++) {
            iface->exns[i]->closure.d_methods = &exception_ops;
        }
    }

    self->d_state->interfaces_by_name->put(iface->rep.name, intf);
    self->d_state->interfaces_by_typecode->put(iface->rep.code.value, intf);

    meta_interface.num_types += 1; // @todo this will cause type traversal to go off-the-board
    kconsole << "register_interface }" << endl;
}

static type_system_f_v1::ops_t typesystem_ops = 
{
    type_system_v1_list,
    type_system_v1_get,
    shared_add,
    shared_remove,
    shared_destroy,
    type_system_v1_info,
    type_system_v1_size,
    type_system_v1_name,
    type_system_v1_is_type,
    type_system_v1_narrow,
    type_system_v1_unalias,
    type_system_f_v1_register_interface
};

//=====================================================================================================================
// Meta-interface
//=====================================================================================================================

static naming_context_v1::names
meta_interface_list(naming_context_v1::closure_t* self)
{
    return naming_context_v1::names();
}

static bool
meta_interface_get(naming_context_v1::closure_t* self, const char* name, types::any* obj)
{
    return false;
}

static bool
meta_interface_v1_extends(interface_v1::closure_t* self, interface_v1::closure_t** o)
{
    return false;
}

static bool
meta_interface_v1_info(interface_v1::closure_t* self, interface_v1::needs* need_list, types::name* name, types::code* code)
{
    return false;
}

static interface_v1::ops_t meta_ops =
{
    meta_interface_list,
    meta_interface_get,
    shared_add,
    shared_remove,
    shared_destroy,
    meta_interface_v1_extends,
    meta_interface_v1_info
};

static interface_v1::closure_t meta_interface_closure =
{
    &meta_ops,
    nullptr
};

//=====================================================================================================================
// Definition of types in the 'mythical' interface meta_interface which defines all predefined Meddle types 
// and all interfaces in Metta (including meta_interface itself).
//=====================================================================================================================

#define PREDEFINED_TYPE_REP(typename,idlname,tag) \
static type_representation_t type_##idlname##_rep = { \
    {  type_system_v1::predefined_type_code, { type_system_v1::predefined_##tag } }, \
    {  types::code_type_code, { idlname##_type_code } }, \
    #idlname, \
    &meta_interface, \
    sizeof(typename) \
}

// @todo When meddler is fixed to accept octet and other types as identifiers, we'll remove the tag part from this.
PREDEFINED_TYPE_REP(uint8_t,octet, Octet);
PREDEFINED_TYPE_REP(int8_t,int8, Char);
PREDEFINED_TYPE_REP(uint16_t,card16, Card16);
PREDEFINED_TYPE_REP(uint32_t,card32, Card32);
PREDEFINED_TYPE_REP(uint64_t,card64, Card64);
PREDEFINED_TYPE_REP(int16_t,int16, Int16);
PREDEFINED_TYPE_REP(int32_t,int32, Int32);
PREDEFINED_TYPE_REP(int64_t,int64, Int64);
PREDEFINED_TYPE_REP(float,float, Float);
PREDEFINED_TYPE_REP(double,double, Double);
PREDEFINED_TYPE_REP(bool,boolean, Boolean);
PREDEFINED_TYPE_REP(cstring_t,string, String);
PREDEFINED_TYPE_REP(voidptr,opaque, Opaque);

static type_representation_t* const meta_interface__types[] =
{
    &type_octet_rep,
    &type_card16_rep,
    &type_card32_rep,
    &type_card64_rep,
    &type_int8_rep,
    &type_int16_rep,
    &type_int32_rep,
    &type_int64_rep,
    &type_float_rep,
    &type_double_rep,
    &type_boolean_rep,
    &type_string_rep,
    &type_opaque_rep
};

interface_v1::state_t meta_interface =
{
    { // representation
        { type_system_v1::iref_type_code, { .ptr32value = &meta_interface_closure } },  // any & cl.ptr
        { types::code_type_code, { meta_interface_type_code } },                        // Type Code
        TCODE_META_NAME,                                                                // Textual name
        &meta_interface,                                                                // Scope
        sizeof(interface_v1::closure_t*)                                                // Size
    }, // end representation
    nullptr,                    // Needs list
    0,                          // No. of needs
    meta_interface__types,      // Types list
    13,                         // No. of types
    true,                       // Local flag
    interface_v1::type_code,    // Supertype
    nullptr,                    // Methods
    0,                          // No. of methods
    nullptr,                    // Exceptions
    0                           // No. of exceptions
};

//=====================================================================================================================
// The Factory
//=====================================================================================================================

static type_system_f_v1::closure_t* 
create(type_system_factory_v1::closure_t* self, heap_v1::closure_t* h, 
       map_card64_address_factory_v1::closure_t* cardmap, map_string_address_factory_v1::closure_t* stringmap)
{
    type_system_f_v1::state_t* state = new(h) type_system_f_v1::state_t;
    closure_init(&state->closure, &typesystem_ops, state);

    state->interfaces_by_typecode = cardmap->create(h);
    state->interfaces_by_name = stringmap->create(h);

    state->closure.register_interface(reinterpret_cast<type_system_f_v1::interface_info>(&meta_interface));
    /*
     * The meta-interface closure is of type "interface_v1" but has different methods
     * since it's state record is type_system state rather than interface_v1::state.
     */
    meta_interface_closure.d_state = reinterpret_cast<interface_v1::state_t*>(state);

    return &state->closure;
}

static type_system_factory_v1::ops_t methods = 
{
    create
};

static type_system_factory_v1::closure_t clos =
{
    &methods,
    nullptr
};

EXPORT_CLOSURE_TO_ROOTDOM(type_system_factory, v1, clos);
