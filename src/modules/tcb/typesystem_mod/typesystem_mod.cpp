//
// Part of Metta OS. Check http://metta.exquance.com for latest version.
//
// Copyright 2007 - 2012, Stanislav Karchebnyy <berkus@exquance.com>
//
// Distributed under the Boost Software License, Version 1.0.
// (See file LICENSE_1_0.txt or a copy at http://www.boost.org/LICENSE_1_0.txt)
//
#include "type_system_f_v1_interface.h"
#include "type_system_f_v1_impl.h"
#include "type_system_factory_v1_interface.h"
#include "type_system_factory_v1_impl.h"
#include "interface_v1_interface.h"
#include "interface_v1_impl.h"
#include "map_card64_address_factory_v1_interface.h"
#include "map_string_address_factory_v1_interface.h"
#include "heap_new.h"
#include "default_console.h"
#include "exceptions.h"

/**
 * @defgroup typecode Type code
 *
 * Type code is 64 bit entity consisting of 48-bit unique identifier for the interface type plus 16 bit entity for indexing subtypes inside the interface
 * (exceptions, aliases, structures, etc.)
 * 48 bit code is generated by meddler while parsing the interface file. It attempts to maintain some sort of stability for type codes for same interfaces.
 * 16 bit code is just a sequential enumeration of all types inside an interface.
 */

struct type_system_f_v1::state_t
{
    type_system_f_v1::closure_t closure;
    map_card64_address_v1::closure_t* interfaces_by_typecode;
    map_string_address_v1::closure_t* interfaces_by_name;
};

//=====================================================================================================================
// add, remove, dup and destroy methods from naming_context are all nulls.
//=====================================================================================================================

static void
shared_add(naming_context_v1::closure_t*, const char*, types::any)
{
    OS_RAISE((exception_support_v1::id)"naming_context_v1.denied", NULL);
    return;
}

static void
shared_remove(naming_context_v1::closure_t*, const char*)
{ 
    OS_RAISE((exception_support_v1::id)"naming_context_v1.denied", NULL);
    return; 
}

// dup is not yet defined, but it raises denied as well

static void
shared_destroy(naming_context_v1::closure_t*)
{ 
    return; 
}

//=====================================================================================================================
// Typesystem
//=====================================================================================================================

static naming_context_v1::names
type_system_v1_list(naming_context_v1::closure_t* self)
{
    return naming_context_v1::names();
}

static bool
type_system_v1_get(naming_context_v1::closure_t* self, const char* name, types::any* obj)
{
    return false;
}

static interface_v1::closure_t*
type_system_v1_info(type_system_v1::closure_t* self, type_system_v1::alias tc, types::any* rep)
{
    return 0;
}

static memory_v1::size
type_system_v1_size(type_system_v1::closure_t* self, type_system_v1::alias tc)
{
    return 0;
}

static types::name
type_system_v1_name(type_system_v1::closure_t* self, type_system_v1::alias tc)
{
    return types::name();
}

static bool
type_system_v1_is_type(type_system_v1::closure_t* self, type_system_v1::alias sub, type_system_v1::alias super)
{
    return false;
}

static types::val
type_system_v1_narrow(type_system_v1::closure_t* self, types::any a, type_system_v1::alias tc)
{
    return types::val();
}

static type_system_v1::alias
type_system_v1_unalias(type_system_v1::closure_t* self, type_system_v1::alias tc)
{
    return type_system_v1::alias();
}

static void
type_system_f_v1_register_interface(type_system_f_v1::closure_t* self, type_system_f_v1::interface_info intf)
{
    kconsole << "register_interface" << endl;
}

static type_system_f_v1::ops_t typesystem_ops = 
{
    type_system_v1_list,
    type_system_v1_get,
    shared_add,
    shared_remove,
    shared_destroy,
    type_system_v1_info,
    type_system_v1_size,
    type_system_v1_name,
    type_system_v1_is_type,
    type_system_v1_narrow,
    type_system_v1_unalias,
    type_system_f_v1_register_interface
};

//=====================================================================================================================
// Meta-interface
//=====================================================================================================================

static bool
interface_v1_extends(interface_v1::closure_t* self, interface_v1::closure_t** o)
{
    return false;
}

static bool
interface_v1_info(interface_v1::closure_t* self, interface_v1::needs* need_list, types::name* name, types::code* code)
{
    return false;
}

static interface_v1::ops_t meta_ops =
{
    type_system_v1_list,
    type_system_v1_get,
    shared_add,
    shared_remove,
    shared_destroy,
    interface_v1_extends,
    interface_v1_info
};

interface_v1::closure_t meta_interface_closure =
{
    &meta_ops,
    NULL
};

//=====================================================================================================================
// The Factory
//=====================================================================================================================

static type_system_f_v1::closure_t* 
create(type_system_factory_v1::closure_t* self, heap_v1::closure_t* h, 
       map_card64_address_factory_v1::closure_t* cardmap, map_string_address_factory_v1::closure_t* stringmap)
{
    type_system_f_v1::state_t* state = new(h) type_system_f_v1::state_t;
    closure_init(&state->closure, &typesystem_ops, state);

    state->interfaces_by_typecode = cardmap->create(h);
    state->interfaces_by_name = stringmap->create(h);

    // state->closure.register_interface(meta_interface);
    /* The meta-interface closure is of type "interface_v1" but has different methods 
       since it's state record is type_system state rather than Intf_st. */
    meta_interface_closure.d_state = reinterpret_cast<interface_v1::state_t*>(state);

#if 0
    /* Could do with some base types! */
    Ts_RegisterIntf(&res->cl, (TypeSystemF_IntfInfo)&IREF__intf);
    *(addr_t *)(&meta_cl.st) = res;  /* XXX n.b. this writes 'const' data */
#endif
    return &state->closure;
}

static type_system_factory_v1::ops_t methods = 
{
    create
};

static type_system_factory_v1::closure_t clos =
{
    &methods,
    NULL
};

EXPORT_CLOSURE_TO_ROOTDOM(type_system_factory, v1, clos);
