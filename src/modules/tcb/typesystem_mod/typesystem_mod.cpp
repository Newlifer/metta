//
// Part of Metta OS. Check http://metta.exquance.com for latest version.
//
// Copyright 2007 - 2012, Stanislav Karchebnyy <berkus@exquance.com>
//
// Distributed under the Boost Software License, Version 1.0.
// (See file LICENSE_1_0.txt or a copy at http://www.boost.org/LICENSE_1_0.txt)
//
#include "type_system_v1_interface.h"
#include "type_system_f_v1_interface.h"
#include "type_system_f_v1_impl.h"
#include "type_system_factory_v1_interface.h"
#include "type_system_factory_v1_impl.h"
#include "enum_v1_interface.h"
#include "record_v1_interface.h"
#include "operation_v1_interface.h"
#include "interface_v1_state.h"
#include "interface_v1_impl.h"
#include "map_card64_address_factory_v1_interface.h"
#include "map_string_address_factory_v1_interface.h"
#include "map_card64_address_v1_interface.h"
#include "map_string_address_v1_interface.h"
#include "heap_new.h"
#include "default_console.h"
#include "exceptions.h"
#include "debugger.h"

/**
 * @defgroup typecode Type code
 *
 * Type code is 64 bit entity consisting of 48-bit unique identifier for the interface type plus 16 bit entity for indexing subtypes inside the interface
 * (exceptions, aliases, structures, etc.)
 * 48 bit code is generated by meddler while parsing the interface file. It attempts to maintain some sort of stability for type codes for same interfaces.
 * 16 bit code is just a sequential enumeration of all types inside an interface.
 */

//=====================================================================================================================
// Type system internal data structures.
//=====================================================================================================================

struct type_system_f_v1::state_t
{
    type_system_f_v1::closure_t        closure;
    map_card64_address_v1::closure_t*  interfaces_by_typecode;
    map_string_address_v1::closure_t*  interfaces_by_name;
};

extern interface_v1::state_t meta_interface; // forward declaration

//=====================================================================================================================
// add, remove, dup and destroy methods from naming_context are all nulls.
//=====================================================================================================================

static void
shared_add(naming_context_v1::closure_t*, const char*, types::any)
{
    OS_RAISE((exception_support_v1::id)"naming_context_v1.denied", 0);
    return;
}

static void
shared_remove(naming_context_v1::closure_t*, const char*)
{ 
    OS_RAISE((exception_support_v1::id)"naming_context_v1.denied", 0);
    return; 
}

// dup is not yet defined, but it raises denied as well

static void
shared_destroy(naming_context_v1::closure_t*)
{ 
    return; 
}

//=====================================================================================================================
// Typesystem
//=====================================================================================================================

static naming_context_v1::names
type_system_v1_list(naming_context_v1::closure_t* self)
{
    return naming_context_v1::names();
}

static bool
type_system_v1_get(naming_context_v1::closure_t* self, const char* name, types::any* obj)
{
    return false;
}

static interface_v1::closure_t*
type_system_v1_info(type_system_v1::closure_t* self, type_system_v1::alias tc, types::any* rep)
{
    return 0;
}

static memory_v1::size
type_system_v1_size(type_system_v1::closure_t* self, type_system_v1::alias tc)
{
    interface_v1::state_t* iface = nullptr;

    /* Check the type code refers to a valid interface */
    if (!reinterpret_cast<type_system_f_v1::state_t*>(self->d_state)->interfaces_by_typecode->get(TCODE_INTF_CODE(tc), (address_t*)&iface))
        OS_RAISE((exception_support_v1::id)"type_system_v1.bad_code", tc);

    /* Deal with the case where the type code refers to an interface type */
    if (TCODE_IS_INTERFACE (tc))
        return iface->rep.size;
  
    /* Check that within the given interface this is a valid type */
    if (!TCODE_VALID_TYPE (tc, iface))
        OS_RAISE((exception_support_v1::id)"type_system_v1.bad_code", tc);

    return TCODE_WHICH_TYPE(tc, iface)->size;
}

static types::name
type_system_v1_name(type_system_v1::closure_t* self, type_system_v1::alias tc)
{

    //     TypeSystem_st *st   = (TypeSystem_st *) self->st;
    // Intf_st   *b    = NULL;
    // Type_Name      name = NULL;
    // TypeRep_t     *tr;

    // /* Check the type code refers to a valid interface */
    // if (!LongCardTbl$Get (st->intfsByTC, TCODE_INTF_CODE (tc), (addr_t*)&b))
    // RAISE_TypeSystem$BadCode(tc);

    // /* Deal with the case where the type code refers to an interface type */
    // if (TCODE_IS_INTERFACE (tc)) {
    // name = strdup(b->rep.name);
    // if(!name) RAISE_Heap$NoMemory();
    // return name;
    // }

    // /* Check that within the given interface this is a valid type */
    // if (! TCODE_VALID_TYPE (tc, b))
    // RAISE_TypeSystem$BadCode (tc);

    // tr = TCODE_WHICH_TYPE (tc, b);
    // name = strdup(tr->name);
    // if(!name) RAISE_Heap$NoMemory();

    // return name;

    return types::name();
}

static bool
type_system_v1_is_type(type_system_v1::closure_t* self, type_system_v1::alias sub, type_system_v1::alias super)
{
    return false;
}

static types::val
type_system_v1_narrow(type_system_v1::closure_t* self, types::any a, type_system_v1::alias tc)
{
    return types::val();
}

static type_system_v1::alias
type_system_v1_unalias(type_system_v1::closure_t* self, type_system_v1::alias tc)
{
    return type_system_v1::alias();
}

/*
 * Method suites for all type representation which include a closure.
 */ 
extern interface_v1::ops_t interface_ops;
extern operation_v1::ops_t operation_ops;
extern exception_v1::ops_t exception_ops;
extern record_v1::ops_t    record_ops;
extern enum_v1::ops_t      enum_ops;
// extern choice_v1::ops_t    choice_ops;

static void
type_system_f_v1_register_interface(type_system_f_v1::closure_t* self, type_system_f_v1::interface_info intf)
{
    interface_v1::state_t* iface = reinterpret_cast<interface_v1::state_t*>(intf); // @todo do we need to convert this back and forth?
    address_t dummy;

    kconsole << "register_interface '" << iface->rep.name << "' {" << endl;

    if (self->d_state->interfaces_by_name->get(iface->rep.name, &dummy))
        OS_RAISE((exception_support_v1::id)"type_system_f_v1.name_clash", 0);

    if (self->d_state->interfaces_by_typecode->get(iface->rep.code.value, &dummy))
        OS_RAISE((exception_support_v1::id)"type_system_f_v1.type_code_clash", 0);

    if (iface != &meta_interface) // meta_interface needs no patching, it's all set up.
    {
        address_t clos_ptr;
        size_t i;

        /* Fill in operation tables of closures */
        reinterpret_cast<interface_v1::closure_t*>(iface->rep.any.value)->d_methods = &interface_ops;

        /* Types */
        for (i = 0; i < iface->num_types; i++)
        {
            clos_ptr = iface->types[i]->any.value;
            switch (iface->types[i]->any.type_)
            {
                // case type_system_v1::choice_type_code:
                //     reinterpret_cast<choice_v1::closure_t*>(clos_ptr)->d_methods = &choice_ops;
                //     break;
                case type_system_v1::enum__type_code:
                    reinterpret_cast<enum_v1::closure_t*>(clos_ptr)->d_methods = &enum_ops;
                    break;
                case type_system_v1::record__type_code:
                    reinterpret_cast<record_v1::closure_t*>(clos_ptr)->d_methods = &record_ops;
                    break;
            }
        }

        /* Operations */
        for (i = 0; i < iface->num_methods; i++) {
            iface->methods[i]->closure->d_methods = &operation_ops;
        }

        /* Exceptions */
        for (i = 0; i < iface->num_exns; i++) {
            iface->exns[i]->closure.d_methods = &exception_ops;
        }
    }

    self->d_state->interfaces_by_name->put(iface->rep.name, intf);
    self->d_state->interfaces_by_typecode->put(iface->rep.code.value, intf);

    meta_interface.num_types += 1; // @todo this will cause type traversal to go off-the-board
    kconsole << "register_interface }" << endl;
}

static type_system_f_v1::ops_t typesystem_ops = 
{
    type_system_v1_list,
    type_system_v1_get,
    shared_add,
    shared_remove,
    shared_destroy,
    type_system_v1_info,
    type_system_v1_size,
    type_system_v1_name,
    type_system_v1_is_type,
    type_system_v1_narrow,
    type_system_v1_unalias,
    type_system_f_v1_register_interface
};

//=====================================================================================================================
// Meta-interface
//=====================================================================================================================

static naming_context_v1::names
meta_interface_list(naming_context_v1::closure_t* self)
{
    return naming_context_v1::names();
}

static bool
meta_interface_get(naming_context_v1::closure_t* self, const char* name, types::any* obj)
{
    return false;
}

static bool
meta_interface_v1_extends(interface_v1::closure_t* self, interface_v1::closure_t** o)
{
    return false;
}

static bool
meta_interface_v1_info(interface_v1::closure_t* self, interface_v1::needs* need_list, types::name* name, types::code* code)
{
    return false;
}

static interface_v1::ops_t meta_ops =
{
    meta_interface_list,
    meta_interface_get,
    shared_add,
    shared_remove,
    shared_destroy,
    meta_interface_v1_extends,
    meta_interface_v1_info
};

static interface_v1::closure_t meta_interface_closure =
{
    &meta_ops,
    nullptr
};

//=====================================================================================================================
// Definition of types in the 'mythical' interface meta_interface which defines all predefined Meddle types 
// and all interfaces in Metta (including meta_interface itself).
//=====================================================================================================================

#define PREDEFINED_TYPE_REP(typename,idlname,tag) \
static type_representation_t type_##idlname##_rep = { \
    {  type_system_v1::predefined_type_code, { type_system_v1::predefined_##tag } }, \
    {  types::code_type_code, { idlname##_type_code } }, \
    #idlname, \
    &meta_interface, \
    sizeof(typename) \
}

// @todo When meddler is fixed to accept octet and other types as identifiers, we'll remove the tag part from this.
PREDEFINED_TYPE_REP(uint8_t,octet, Octet);
PREDEFINED_TYPE_REP(int8_t,int8, Char);
PREDEFINED_TYPE_REP(uint16_t,card16, Card16);
PREDEFINED_TYPE_REP(uint32_t,card32, Card32);
PREDEFINED_TYPE_REP(uint64_t,card64, Card64);
PREDEFINED_TYPE_REP(int16_t,int16, Int16);
PREDEFINED_TYPE_REP(int32_t,int32, Int32);
PREDEFINED_TYPE_REP(int64_t,int64, Int64);
PREDEFINED_TYPE_REP(float,float, Float);
PREDEFINED_TYPE_REP(double,double, Double);
PREDEFINED_TYPE_REP(bool,boolean, Boolean);
PREDEFINED_TYPE_REP(cstring_t,string, String);
PREDEFINED_TYPE_REP(voidptr,opaque, Opaque);

static type_representation_t* const meta_interface__types[] =
{
    &type_octet_rep,
    &type_card16_rep,
    &type_card32_rep,
    &type_card64_rep,
    &type_int8_rep,
    &type_int16_rep,
    &type_int32_rep,
    &type_int64_rep,
    &type_float_rep,
    &type_double_rep,
    &type_boolean_rep,
    &type_string_rep,
    &type_opaque_rep
};

interface_v1::state_t meta_interface =
{
    { // representation
        { type_system_v1::iref_type_code, { .ptr32value = &meta_interface_closure } },  // any & cl.ptr
        { types::code_type_code, { meta_interface_type_code } },                        // Type Code
        TCODE_META_NAME,                                                                // Textual name
        &meta_interface,                                                                // Scope
        sizeof(interface_v1::closure_t*)                                                // Size
    }, // end representation
    nullptr,                    // Needs list
    0,                          // No. of needs
    meta_interface__types,      // Types list
    13,                         // No. of types
    true,                       // Local flag
    interface_v1::type_code,    // Supertype
    nullptr,                    // Methods
    0,                          // No. of methods
    nullptr,                    // Exceptions
    0                           // No. of exceptions
};

//=====================================================================================================================
// The Factory
//=====================================================================================================================

#include "c++ctors.h"

static type_system_f_v1::closure_t* 
create(type_system_factory_v1::closure_t* self, heap_v1::closure_t* h, 
       map_card64_address_factory_v1::closure_t* cardmap, map_string_address_factory_v1::closure_t* stringmap)
{
    type_system_f_v1::state_t* state = new(h) type_system_f_v1::state_t;
    closure_init(&state->closure, &typesystem_ops, state);

    state->interfaces_by_typecode = cardmap->create(h);
    state->interfaces_by_name = stringmap->create(h);

    state->closure.register_interface(reinterpret_cast<type_system_f_v1::interface_info>(&meta_interface));
    /*
     * The meta-interface closure is of type "interface_v1" but has different methods
     * since it's state record is type_system state rather than interface_v1::state.
     */
    meta_interface_closure.d_state = reinterpret_cast<interface_v1::state_t*>(state);

    return &state->closure;
}

static type_system_factory_v1::ops_t methods = 
{
    create
};

static type_system_factory_v1::closure_t clos =
{
    &methods,
    nullptr
};

EXPORT_CLOSURE_TO_ROOTDOM(type_system_factory, v1, clos);
