#include "type_system_f_v1_interface.h"
#include "type_system_f_v1_impl.h"
#include "type_system_factory_v1_interface.h"
#include "type_system_factory_v1_impl.h"
#include "map_card64_address_factory_v1_interface.h"
#include "map_string_address_factory_v1_interface.h"
#include "heap_new.h"
#include "default_console.h"

// typecodes are generated by taking first 48 bits of md5 of internal AST representation of the interface in Nemesis...
// (tools/astgen/asthandle.py)
// a simplistic approach for metta would be to take a digest of interface name, and maybe parent interface name.

struct type_system_f_v1::state_t
{
	type_system_f_v1::closure_t closure;
	map_card64_address_v1::closure_t* interfaces_by_typecode;
	map_string_address_v1::closure_t* interfaces_by_name;
};

//=====================================================================================================================
// Typesystem
//=====================================================================================================================

static void
type_system_f_v1_register_interface(type_system_f_v1::closure_t* self, type_system_f_v1::interface_info intf)
{
	kconsole << "register_interface" << endl;
}

static type_system_f_v1::ops_t typesystem_ops = 
{
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	type_system_f_v1_register_interface
};

//=====================================================================================================================
// The Factory
//=====================================================================================================================

static type_system_f_v1::closure_t* create(type_system_factory_v1::closure_t* self, heap_v1::closure_t* h, 
	map_card64_address_factory_v1::closure_t* cardmap, map_string_address_factory_v1::closure_t* stringmap)
{
	type_system_f_v1::state_t* state = new(h) type_system_f_v1::state_t;
	closure_init(&state->closure, &typesystem_ops, state);

	state->interfaces_by_typecode = cardmap->create(h);
	state->interfaces_by_name = stringmap->create(h);
#if 0
    /* Could do with some base types! */
    Ts_RegisterIntf(&res->cl, (TypeSystemF_IntfInfo)&IREF__intf);

    /* The meta-interface closure (IREF) is of type "Interface" but
       has different methods since it's state record is TypeSystem_st
       rather than Intf_st. */
    *(addr_t *)(&meta_cl.st) = res;  /* XXX n.b. this writes 'const' data */
#endif
    return &state->closure;
}

static type_system_factory_v1::ops_t methods = 
{
	create
};

static type_system_factory_v1::closure_t clos =
{
	&methods,
	NULL
};

EXPORT_CLOSURE_TO_ROOTDOM(type_system_factory, v1, clos);
