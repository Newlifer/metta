-- Type system provides reflection on types available in the system.
--
--
-- Much like Modula-3 types.
--
-- Ordinal types:
--
-- enum { id_1, id_2, id_3 } E;
-- set<enum> S;
-- range id_1..id_2 R;
-- int8
-- int16
-- int32
-- int64
-- octet
-- card16
-- card32
-- card64
--
-- Floating point types:
--
-- float
-- double
--
-- Array types:
--
-- type V[range][range]; -- e.g. octet bytes[128][1..2];
--
-- Record types:
--
-- record { type field = default; type field = default } id;
--

local interface type_system_v1 extends naming_context_v1
{
    type.code alias;

    enum { Boolean, ShortCardinal, Cardinal, LongCardinal,
          ShortInteger, Integer, LongInteger,
          Real, LongReal,
          String,
          Octet, Char,
          Address, Word } predefined;

    cardinal array_index;
    record { array_index n; alias tc; } array;
--     cardinal bit_set;//?
--     enum_v1& enum;
--     alias    set;
--     alias    ref;
--     interface_v1& iref;
--     alias    sequence;
--     struct&  struct;
--     choice&  choice;

    exception bad_code { alias code; }
    exception incompatible {}

    info(alias tc, out type.any rep) returns (interface_v1& scope) raises (bad_code);

    size(alias tc) returns (heap_v1.size s) raises (bad_code);

    name(alias tc) returns (type.name name) raises (bad_code);

    is_type(alias sub, super) returns (boolean result) raises (bad_code);

    narrow(type.any a, alias tc) returns (type.val v) raises (incompatible);

    unalias(alias tc)=>(alias base) raises (bad_code);
}
