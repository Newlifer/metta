--
-- Much like Modula-3 types.
--
-- Ordinal types:
--
-- set { id_1, id_2, id_3 } S;
-- range id_1..id_2 R;
-- int8
-- int16
-- int32
-- int64
-- octet
-- card16
-- card32
-- card64
--
-- Floating point types:
--
-- float
-- double
--
-- Array types:
--
-- type V[range][range]; -- e.g. octet bytes[128][1..2];
--
-- Record types:
--
-- record { type field = default; type field = default } id;
--

local interface type_system_v1 extends naming_context_v1
{
    needs type, enum_v1, interface_v1, record_v1, choice_v1;

    type.code alias;

    set { Boolean, ShortCardinal, Cardinal, LongCardinal,
          ShortInteger, Integer, LongInteger,
          Real, LongReal,
          String,
          Octet, Char,
          Address, Word } predefined;
    range 0..15 hexnibble;

    cardinal array_index;
    record { array_index n; alias tc; } array;
--     cardinal bit_set;//?
--     enum_v1& enum;
--     alias    set;
--     alias    ref;
--     interface_v1& iref;
--     alias    sequence;
--     struct&  struct;
--     choice&  choice;

    exception bad_code { alias code; }
    exception incompatible {}

    info(alias tc, out type.any rep)=>(interface_v1& scope) raises bad_code;

    size(alias tc)=>(heap_v1.size s) raises bad_code;

    name(alias tc)=>(type.name name) raises bad_code;

    is_type(alias sub, super)=>(boolean result) raises bad_code;

    narrow(type.any a, alias tc)=>(type.val v) raises incompatible;

    unalias(alias tc)=>(alias base) raises bad_code;
}
