MMgmt in Nemesis:

ramtab - list of allocated physical frame ranges and their ownership and status

Either mapping or unmapping a virtual address va requires that the calling domain is executing in a protection domain
which holds a meta right for the stretch containing va. A consequence of this is that it is not possible to map
a virtual address which is not part of some stretch.

** For Metta: domain attr: list_t<stretch_t*> stretches;

It is also necessary that the frame which is being used for mapping (or which is being unmapped) is validated.
This involves ensuring that the calling domain owns the frame, and that the frame is not currently mapped or nailed.
These conditions are checked by using the RamTab, which is a simple enough structure to be used by low-level code.


stretch_allocator [privileged]
  - range lists of available virtual memory ranges
  + allocate_stretch
  + release_stretch

frame_allocator [privileged]
  - range lists of available physical memory ranges
  + allocate_frame
  + free_frame

protection_domain (via stretch_allocator?) [kernel]
  - stretches list
  + get stretch for given va?

stretch_driver (bound to stretch) [userspace]
  1. map(va, pa, attr) : arrange that the virtual address va maps onto the physical address pa with the (machine-dependent) PTE attributes attr.
  2. unmap(va) : remove the mapping of the virtual address va. Any further access to the address should cause some form of memory fault.
  3. mapping(va) ->  (pa, attr) : retrieve the current mapping of the virtual address va, if any.
  --> frame_allocator::allocate_region (uses constraints to allocate specific physmem for stretch)
  --> routed to prot_dom mapping api? via syscalls


Memory protection operations are carried out by the application through the stretch interface. This talks directly to the low-level translation system via simple system calls; it is not necessary to communicate with the system domain. Protection can be carried out in this way due to the protection model chosen which includes explicit rights for ``change permissions'' operations. A light-weight validation process checks if the caller is authorised to perform an operation.


Any domain may request a stretch from a stretch allocator, specifying the desired size and (optionally) a starting address and attributes. Should the request be successful, a new stretch will be created and returned to the caller. The caller is now the owner of the stretch. The starting address and length of the returned stretch may then be queried; these will always be a multiple of the machine's page size3.

Protection is carried out at stretch granularity -- every protection domain provides a mapping from the set of valid stretches to a subset of   read, write, execute, meta . A domain which holds the meta right is authorised to modify protections and mappings on the relevant stretch.



