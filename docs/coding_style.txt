This document describes coding conventions used in Metta, be sure to comply to these guidelines to make merging easier.

This document is based on work by
    Scott Wheeler
    Stanislav Karchebny
    Frank Osterfeld
    Ludvig Borgne


========================================================================================================================
1. Names
========================================================================================================================

The following guidelines deal with naming of types, attributes, variables, constants, functions, namespaces etc:

a. The following names shall be in lowercase C style:
    * Types
    * Named constants
    * Enum values
    * Namespaces
    * Methods and functions
    * Attributes
    * Variables

b. The following names should be in uppercase C style:
    * Defined preprocessor macro names
    * Defined constant names

c. Names of template parameters shall be single uppercase letters or C style lowercase identifiers. In complex stl-like
   code with many typedefs it is allowed to name template parameters in CamelCase.

d. Names of methods and functions shall start with a verb.

    format_string();
    process_data();

e. Accessors shall begin with "set" for setters and no prefix for getters.

    int length();
    void set_length(int new_length);

    If internal property name is the same as accessor function name, property name shall have "_" appended.

    int length_;

f. Plural form shall be used for names representing a collection of objects.

    list_t<rectangle_t> rectangles;
    int points[n_points];

g. Avoid long variable names in code blocks. When code is sufficiently concise variable meaning should be obvious.
   Do not save on instance and class variable names though, these are visible throughout the class and serve documentary
   purposes.

h. Boolean variables and methods (including accessors) shall use suitable prefixes, such as "is", "has" or "can".

    bool is_open;
    bool has_subject(email& mail);

i. Types have _t appended (some types inside namespaces can omit it, but rarely). Namespaces have _n suffix. Enums have
   _e suffix:

    typedef int sint32_t;
    class kernel_t;

j. Namespaces nesting should not be abundant. Typically a single level flat namespace is more than enough to group
   classes together.

k. Sometimes namespaces can be plural nouns or adjectives, indicating grouping classes by attribute.

l. Needless to say, all names shall be in English.


========================================================================================================================
2. Files
========================================================================================================================

The following guidelines deal with the naming, contents and structure of source code and header files:

a. C++ header files shall have the extension ".h", and C++ source files shall have the extension ".cpp".

b. A class shall be declared in a header file and defined in a source file, where the names of the files
   match the name of the class. Except in the case of templated classes, where method bodies should be defined
   within the same header file, preferably outside of the class declaration, unless they are very short.

c. All definitions, except inline functions, shall reside in source files.

d. The order of definitions in the source file shall be the same as the order of the corresponding declarations in
   the header file. Unless otherwise required by interdependencies.

e. Line length shall be kept within 120 columns, whenever feasilble.

f. Lines longer than 120 columns shall be split in a way that makes the line readable,
   e.g. by breaking after a comma or an operator, and aligning the new line with the beginning
   of the expression on the previous line.

g. Header files shall contain an include guard. Instead of #define-based include guards

    #ifndef __MEMORY_H
    #define __MEMORY_H
    // .....
    #endif

   better is to use

    #pragma once

h. #include directives shall be located at the top of the file, after the header.
   Header files shall be included in the following order: standard headers, 3rd-party headers, local headers.
   This prevents local include conflicts with global files and allows to redefine standard behavior.


========================================================================================================================
3. Layout
========================================================================================================================

The following guidelines deal with indentation and use of whitespace:

a. Spaces shall always be used instead of tabs.

b. The basic indentation step is 4 spaces.

c. Block bodies, case statements within a switch are indented. Class bodies are indented, however access modifiers
   "public", "protected" and "private" are not.

    switch (arg)
    {
        case 0:
            debug() << "zero!";
            break;

        case 1:
        {
            //  big block with some local vars
            int local_var = 0;
            break;
        }
    }

d. Namespaces are not indented except when in forward declarations (where they indent as block bodies).
   Comment the closing bracket of the namespace with // namespace foo

    namespace boost
    {
        class regexp;
    }

    namespace example_n
    {

    class foo_t
    {
    public:
        foo_t();
    };

    } // namespace example_n

e. Opening brackets are on their own line, except for enumerations and inline functions defined on a single line.

    enum some_enum_e { value1, value2, value3 };

    if (x > y)
    {
        x -= 5;
        y += 5;
    }

    while (foo == bar &&
        baz == quux &&
        flop == pop)
    {
        // stuff
    }

f. Multiple statements should not ever be combined onto one line. Exception is the C++ idiom of deleting a pointer
   and assigning it NULL:

    delete ptr; ptr = NULL;

g. Loop statements such as "if", "for", "foreach", "do...while" and "while" shall have brackets around their blocks
   only if the blocks contain more than one line. "for" statements with empty bodies should be avoided. Side effects in
   single-line bodies should be avoided (e.g. no use of macros as single-line bodies).

h. The condition in an "if" statement shall always be put on a separate line.

    if (x == 5)
        y = x;

i. C++ pointers and references shall have their reference symbol next to the type rather than to the name.

    float* x;
    some_class_t& object;

j. In class declarations, "public" declarations shall precede "protected" declarations which in turn shall precede
   "private" declarations. In many cases "private" declarations may precede all other declarations without specifying
   "private" (using default class access).

   The organization of the members in a class declaration should be roughly as follows:

    private typedefs:      ------+--> used throughout the class
    public typedefs:       ------\
    public ctors/dtors:          |
    public methods:              |
    public slots:                +--> part of the class API
    signals:                     |
    protected slots:             |
    private slots:         ------/
    protected methods:     ------\
    private methods:             |
    private ctors/dtors:         +--> class implementation details
    protected attributes:        |
    private attributes:    ------/

   Methods and attributes should be clearly separated.

k. Virtual functions should always be marked as such even in derived classes where it is not technically necessary.

l. In a function definition, the function return type shall be put above the function name (not to the left of it).

    some_type_t
    some_function(some_other_type_t& object)
    {
        // ...
    }

m. In a template function definition, the function template arguments shall be put to the line above function signature.

    template <typename T, int N>
    some_type_t
    some_function(some_other_type_t& object)
    {
        // ...
    }

n. The following items shall be surrounded by a space character:
    * Conventional operators,
    * Curly braces used in single-lined enum declarations,
    * Curly braces used in single-lined inline function definitions.

    a = 5 + (3 * x) / 2;

o. The following items shall be followed by a space character:
    * C++ reserved words,
    * Commas,
    * Semicolons in "for" statements.

    for (x = 0; x < 10; ++x, y += x)
        do_something(x, y, 0);

p. Function names, operator names in declarations and definitions, various C++ casts operators should not be
   followed by a space character.

    static_cast<void*>(var)
    operator uint32_t();
    operator =(int new_value);

q. Opening parentheses shall not be followed by white space. Closing parentheses shall not be preceded by white space.

r. Logical units within a block shall be separated by one blank line, and each block shall start with a comment
   if it is unclear what the block does.

s. Function definitions shall be separated by two blank lines.

t. Initializer lists in constructors are one assignment per line, indented, with colon or comma before the assignment.
   This allows for easier rearrangement if class layout changes.

    object_t::object_t(int a, double b, other_t& c)
        : parent_t()
        , int_value(a)
        , double_value(b)
        , reference(c)
    {
        // other initialization
    }

u. Variables in declaration blocks and their initialization can be justified to the left whenever it enhances readability.

    int     long_variable_name = 0;
    double  avoid_long_names   = 1.1;
    bool    long_names         = true;

v. Files usually include at the top licensing header from file license_header. Ruby script apply_boilerplate.rb
   can be used to add it to new files.


========================================================================================================================
4. Documentation
========================================================================================================================

The following guidelines deal with comments and documentation of the code:

a. All comments shall be written in English.

b. Use "//" for single-line text comments, and "//" or "/* */" for multi-line text comments.
   "#if 0 ... #endif" preprocessor directives can be used to temporarily disable code without erasing it.
   Eventually, such code shall be removed, though.

c. Classes, functions and methods shall be documented using simple Doxygen comments where they are declared. This means
   functions in public API will carry their own documentation in the header files. Internal documentation can be
   appended by writing it in the source file.

   Doxygen comments shall include a brief description of the method/attribute, and may also contain
   a detailed description, if that is considered necessary.

    /**
     * A brief description of the function, normally on one line until colon.
     * An optional detailed description,
     * normally on several lines.
     */
    void my_function(int x)
    {
        // ...
    }

d. For inline functions, defined on a single line in the header file, a brief description just above the definition is enough.

    /// A brief description of the function.
    void my_inline_function(int x) { a = x; }

e. For structs, enums and attributes, a brief description is enough. Enum values and attributes may be documented
   after the value.

    //! Type of line used for drawing.
    enum line_type_e
    {
        no_line,     /**< No line at all.           */
        thin_line,   /**< Thin line (1-3 pixels).   */
        thick_line,  /**< Thick line (3-9 pixels).  */
    };


========================================================================================================================
5. An example here
========================================================================================================================


test.h:

//
// Copyright 2007 - 2012, Stanislav Karchebnyy <berkus+metta@madfire.net>
//
// Distributed under the Boost Software License, Version 1.0.
// (See file LICENSE_1_0.txt or a copy at http://www.boost.org/LICENSE_1_0.txt)
//
#pragma once

#include <sysinclude1.h>
#include <sysinclude2.h>
#include <extinclude1.h>
#include <extinclude2.h>
#include "localinclude1.h"
#include "anotherlocalinclude.h"

class something_t;

namespace example_n {

/**
 * This is an example test object.
 */
class test_t : public object_t
{
public:
    /// Shorthand type for list of test objects.
    typedef value_list<test_t> list;

    /// Obtain a singleton instance of test class.
    static test_t* instance() { return instance_; } // singleton/factory methods go in constructors place

    virtual ~test_t();

    void perform_func();
    void apply_func2(something_t* sth);

    // accessors
    int   private_var()               { return private_var_; }
    void  set_private_var(int new_v)  { private_var_ = new_v; }

public slots:
    void receive(something_t&);

signals:
    void send(something_t&);

// Protected and private stuff is usually documented in the implementation file.
protected:
    void some_protected_func();
    static void some_protected_static_func();

protected slots:
    void protected_slot();

protected:
    int protected_attr;

private:
    test_t();
    test_t(string_t some_string);

    int private_method();
    static int static_private_method();

private slots:
    void private_slot(int param_pam_pam);

private:
    int private_var_;
    something_t* tasty_thingie;

    static test_t* instance_;
};

} // namespace example_n


test.cpp:

//
// Copyright 2007 - 2009, Stanislav Karchebnyy <berkus+metta@madfire.net>
//
// Distributed under the Boost Software License, Version 1.0.
// (See file LICENSE_1_0.txt or a copy at http://www.boost.org/LICENSE_1_0.txt)
//
#include "test.h" // per Lakos' "Large scale C++ design" component header file is included first.
#include <sysinclude3.h>
#include <extinclude3.h>
#include "localinclude2.h"

namespace example_n
{

test_t* test_t::instance_ = 0;


test_t::test_t()
    : object_t()
    , protected_attr(0)
    , private_var_(0)
    , tasty_thingie(0)
{
}


test_t::test_t(string_t some_string)
    : object_t()
    , protected_attr(0)
    , private_var_(0)
    , tasty_thingie(from_string(some_string))
{
    if (!tasty_thingie)
        debug() << "from_string failed";
}


void
test_t::apply_func2(something_t* sth)
{
    for (int x = 0; x < 10; x++)
        if (x == 5)
            send(*sth);
}

} // namespace example_n


========================================================================================================================
6. astylerc
========================================================================================================================

While astyle cannot fully follow this document's guidelines, it can tremendously help by adjusting style
in a source file to a common base. The following astylerc settings are used:

indent=spaces=4
brackets=linux                         # attach brackets inside functions only
indent-switches
indent-preprocessor
#no-indent-classes
#no-indent-cases
#no-indent-brackets
#no-indent-blocks
#no-indent-namespaces
#no-indent-labels
max-instatement-indent=80
min-conditional-indent=4
break-blocks
delete-empty-lines
unpad-paren
keep-one-line-blocks
convert-tabs


========================================================================================================================
