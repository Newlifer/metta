 ☐ Add bootimage namespace iteration (bootimage_t::namespace_t::iterator?)
 ☐ Finish introspection and write a command line tool to interactively explore type system.
 ☐ Make a real module loader with all tables and proper memory allocation - current one seems to step over already allocated data and needs to preload things in order to work...
 ☐ Make a memory map tool to see what is allocated where, associate stretches and domains with allocated frames.

Assocfs:
    ☐ OS block cache - write tests.
    ☐ write b+tree handler

 ☐ write more unit-tests for all these modules!

 ☐ We need a simple application to start coding from the user perspective. Something simple, single focused and immensely mettaish. Ideas?

 ☐ Create architecture descriptions in increasing level of detail (@sa ANSA engineering overview).


System components:
  ☐ scheduler
  ☐ protection domains
  ✔ memory manager @done (12-12-31 16:58)
  ✔ usermode @done (12-12-31 16:58)

  ✔ UP @done (12-12-31 16:58)
  ☐ SMP
  ☐ NUMA

Nucleus (privileged core):
 TODO: cleanly separate this code into a specialized component
  ☐ IRQ stubs
  ☐ privileged instructions
  ☐ limited set of syscalls for performing privileged instructions - @TODO: make a list now
  ✔ write_pdbr @done (12-12-31 16:59)

Drivers:
  ☐ keyboard (PS/2, usb support needs more drivers)
  ☐ PCI
  ☐ ACPI (using acpica port?)
  ☐ display
  ☐ network

Services:
  ✔ typesystem @done (12-12-31 16:59)
  ☐ events
  ☐ IDC
     ☐ shm transport
     ☐ marshalling & stub generator
     ☐ events plumbing between domains
     ☐ exports table & lookup
  ✔ exceptions @done (12-12-31 16:59)

Applications:
  ☐ test shell
  ☐ child
  ☐ memory inspector
  ☐ symbolic debugger


 ☐ Write tests for atomic_count

Other:
    ☐ Investigate TLSF memory allocator for RT tasks 
        Investigate possible use of TLSF for RT tasks. See http://rtportal.upv.es/rtmalloc/
    ☐ Implement module dependency tracking
        Implement dependency tracking via MODULE_DEPEND() macros, .modinfo section data and module dependency graph building in module loader.
        The actual dependency information should be generated by meddler from interface info and then somehow combined into final dependency record.
    ☐ Implement device tree support
        Perform scanning of the system buses and build a device tree which describes machine configuration.
        A prerequisite for device driver loading and probing.
        Device tree can be represented as a naming_context, mapping various information about devices from arc-names.

Toolchain:
    ☐ Jotun native file format work
    ☐ Migrate linking to gold with LLVM plugin
        One issue with gold was problem with not generating the GOT properly. There's a testcase for this exists and can be used in configuring proper gold setup.
        Another option is to try and build ELF lld with llvm. It sure is very limited at the moment.

Baby steps:
    ☐ Port activations and handlers framework
    ☐ Port gatekeeper
    ☐ Port VCPU operations
    ☐ Implement nucleus syscalls
    ☐ Set up module namespaces tree and global context
    ☐ Port threading packages
        Threads, thread handlers, events, user-level scheduler package.
    ☐ Port IDC machinery
        IDC stubs, marshal, CS IDC stubs, IDC/Shm Transports.
    ☐ Port binder
        Binder, exports table, plumber, event channels.
    ✔ Finish porting naming context operations @done (12-12-31 17:09)
    ☐ Port domain manager

Meddler:
    ☐ Generate dot files with dependency information in meddler
    ☐ Use llvm doxygen scanning functionality
    ☐ Meddler: use newline as a substitute for semicolon where possible

Milestone-1:
    ☐ Start a root thread
       Start and run a single kernel thread in kernel address space with kernel (user?) privileges.

Testing:
    ☐ Devise a testing framework for modules

