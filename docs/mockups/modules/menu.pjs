Menu menu = new Menu();

menu.add_item(new MenuItem("Cut"));
menu.add_item(new MenuItem("Copy"));
menu.add_item(new MenuItem("Paste"));
menu.add_item(new MenuItem("Send to..."));
menu.add_item(new MenuItem("What the?"));
menu.add_item(new MenuItem("Let's party"));
menu.add_item(new MenuItem("Happy New Year"));

menu.set_bounds(-HALF_PI, HALF_PI * 3 / 2);
menu.set_radius(90);

boolean menuShown = false;

void setup() {
    size(600, 600);
    smooth();
    frameRate(30);
  
    menu.prepare();
}

// Main draw loop
void draw() {
  
    background(#666666);
  
    if (menuShown) menu.update();
  
}

void mousePressed() {
   
   menu.set_pos(mouseX, mouseY); 
   menuShown = true;   
   
    if (menuShown) {
       if (menu.mouse_in(mouseX, mouseY)) {
           menu.mouse_click(mouseX, mouseY); 
       } 
    }   
}

void mouseMoved() {
    
    if (menuShown) {
       if (menu.mouse_in(mouseX, mouseY)) {
           menu.mouse_over(mouseX, mouseY); 
       } else {
           menu.mouse_out();
       }
    }
    
}

/* ======================== Component ========================================*/

class Component {

    static Component[] listeners = new Component[];
    
    static void add_listener(Component comp) {
        listeners[listeners.length] = comp;
    };  
    
    static void add_listeners(Component[] comps) {
        for (int i = 0; i < comps.length; i++) {
            listeners[listeners.length] = comps[i];
        }
    };      

    static boolean mouse_in(float mouse_x, float mouse_y) { 
        for (int i = 0; i < listeners.length; i++) {
            if (listeners[i].is_mouse_in(mouse_x, mouse_y)) {
                return true;
            }
        }
        return false;
    };
    
    static void mouse_over(float mouse_x, float mouse_y) { 
        for (int i = 0; i < listeners.length; i++) {
            if (listeners[i].is_mouse_in(mouse_x, mouse_y)) {
                listeners[i].on_mouse_over(mouse_x, mouse_y);
            }
        }
    };  
    
    static void mouse_out() { 
        for (int i = 0; i < listeners.length; i++) {
            listeners[i].on_mouse_out();
        }
    }; 
        
    
    static void mouse_click(float mouse_x, float mouse_y) { 
        for (int i = 0; i < listeners.length; i++) {
            if (listeners[i].is_mouse_in(mouse_x, mouse_y)) {
                listeners[i].on_mouse_click(mouse_x, mouse_y);
            }
        }
    };
    
    boolean is_mouse_in(float mouse_x, float mouse_y) { return false; };    
    boolean on_mouse_over(float mouse_x, float mouse_y) { return true; };
    boolean on_mouse_click(float mouse_x, float mouse_y) { return true; };
    boolean on_mouse_out() { return true; };    
    void update() {};    

}

/* ======================== RadialComponent ==================================*/

class RadialComponent extends Component {

    float center_x, center_y = .0;

    void set_pos(float center_x, float center_y) {
        this.center_x = center_x;
        this.center_y = center_y;
    }

};

/* ======================== MenuCloseButton ==================================*/

class MenuCloseButton extends RadialComponent {
        
    float btn_radius = 10;
    color button_color = color(#660000);
    
    MenuCloseButton() {

    } 
    
    void update() {
        fill(button_color);   
        ellipse(center_x, center_y, btn_radius * 2, btn_radius * 2);
    }
    
    boolean is_mouse_in(float mouse_x, float mouse_y) {        
        if ((abs(center_x - mouse_x) <= btn_radius) &&
            (abs(center_y - mouse_y) <= btn_radius)) {
             float at_angle = atan2(mouse_y - center_y, mouse_x - center_x);
             float x_way = btn_radius * abs(cos(at_angle));
             float y_way = btn_radius * abs(sin(at_angle));
             return (((center_x - x_way) <= mouse_x) &&
                     ((center_y - y_way) <= mouse_y) &&
                     ((center_x + x_way) >= mouse_x) &&
                     ((center_y + y_way) <= mouse_y));
        } else {
            return false;
        }
    } 
    
    boolean on_mouse_over(float mouse_x, float mouse_y) {
        button_color = color(#ffffff);
    }    
    
    boolean on_mouse_out() {
        button_color = color(#660000);
    }    
    
}

/* ======================== MenuItem =========================================*/

class MenuItem extends RadialComponent {

    String name;

    color item_color, over_color = null;
    float start_radius, end_radius = null;
    float start_angle, end_angle = null;
    
    MenuItem(String name) {
        this.name = name;
    }
    
    void set_radius(float start_radius, float end_radius) {
        this.start_radius = start_radius;
        this.end_radius = end_radius;
    }
    
    boolean is_radius_set() {
        return (start_radius != null) &&
               (end_radius != null);
    }
    
    void set_angle(float start_angle, float end_angle) {
        this.start_angle = start_angle;
        this.end_angle = end_angle;
    }
    
    boolean is_angle_set() {
        return (start_angle != null) &&
               (end_angle != null);        
    }
    
    void set_color(color item_color) {
        this.item_color = item_color;
    }
    
    boolean is_color_set() {
        return (item_color != null);
    }    

    void update() {        
        fill(item_color);
        arc(center_x, center_y, 
            end_radius * 2, end_radius * 2, 
            start_angle, end_angle); // outer arc
        noFill();
        arc(center_x, center_y, 
            start_radius * 2, start_radius * 2, 
            start_angle, end_angle); // inner arc
    }
    
    boolean is_mouse_in(float mouse_x, float mouse_y) {        
        if ((abs(center_x - mouse_x) <= end_radius) &&
            (abs(center_y - mouse_y) <= end_radius) &&
            (abs(center_x - mouse_x) >= start_radius) &&
            (abs(center_y - mouse_y) >= start_radius)) {
            float at_angle = atan2(mouse_y - center_y, mouse_x - center_x);
            if ((abs(at_angle) >= abs(start_angle)) && 
                (abs(at_angle) <= abs(end_angle))) { 
                float x_way = end_radius * abs(cos(at_angle));
                float y_way = end_radius * abs(sin(at_angle));
                return (((center_x - x_way) <= mouse_x) &&
                        ((center_y - y_way) <= mouse_y) &&
                        ((center_x + x_way) >= mouse_x) &&
                        ((center_y + y_way) <= mouse_y));   
            } else {
                return false;
            }
        } else {
            return false;
        }
    }
    
    boolean on_mouse_over(float mouse_x, float mouse_y) {
        item_color = color(#ffffff);
    }
    
    boolean on_mouse_out(float mouse_x, float mouse_y) {
        item_color = color(#333333);
    } 

};

/* ======================== Menu =============================================*/

class Menu extends RadialComponent {

    color stroke_color = color(#eeeeee);
    color start_color = color(#000033);
    color end_color = color(#000066);
    // color[] items_colors;
    
    float menu_radius = 90;
    float start_angle = -HALF_PI;
    float end_angle = HALF_PI * 3 / 2;

    MenuItem[] items;
    MenuCloseButton close_btn;
    
    Menu(MenuItem[] items) {
        close_btn = new MenuCloseButton();
        add_listener(close_btn); 
               
        this.items = items;
        add_listeners(this.items);
    }
    
    /* Menu(String[] items_names) {  // FIXME: setting through array moves in recursion
        close_btn = new MenuCloseButton();
        add_listener(close_btn);
        
        for (int i = 0; i < items_names.length; i++) {
            add_item(new MenuItem(items_names[i]));
        }
    }  */
    
    Menu() {
        close_btn = new MenuCloseButton();
        add_listener(close_btn);
        
        items = new MenuItem[];
    }
    
    void add_item(MenuItem item) {
        items[items.length] = item;
        add_listener(item);
    }
    
    void add_item(String item_name) {
        // add_item(new MenuItem(item_name));
        MenuItem item = new MenuItem(item_name);
        items[items.length] = item; 
        add_listener(item);   
    }
    
    void set_bounds(float start_angle, float end_angle) {
        this.start_angle = start_angle;
        this.end_angle = end_angle;
    }
    
    void set_radius(float new_radius) {
        this.menu_radius = new_radius;
    }
    
    void prepare() {
        // called on processing setup()
        float angle_step = (end_angle - start_angle) / items.length;
        float start_radius = close_btn.btn_radius /*+ 1*/;
        float lerp_amount = 1 / items.length;
        
        float cur_color = start_color;
        float cur_start_angle = start_angle;
        float cur_end_angle = cur_start_angle + angle_step;
        
        for (int i = 0; i < items.length; i++) {
            
            MenuItem item = items[i];
            if (!item.is_color_set())  item.set_color(cur_color);            
            if (!item.is_radius_set()) item.set_radius(start_radius, 
                                                       menu_radius);
            if (!item.is_angle_set())  item.set_angle(cur_start_angle, 
                                                      cur_end_angle);
            
            cur_start_angle += angle_step;
            cur_end_angle = cur_start_angle + angle_step;
            
            cur_color = lerpColor(start_color, end_color, lerp_amount * (i + 1));
        }        
    }

    void update() {
        stroke(stroke_color);
        for (int i = 0; i < items.length; i++) {
            items[i].update();
        }
        close_btn.update();
    }
    
    void set_pos(float center_x, float center_y) {
        close_btn.set_pos(center_x, center_y);
        for (int i = 0; i < items.length; i++) {
            items[i].set_pos(center_x, center_y);
        }
    }

};
