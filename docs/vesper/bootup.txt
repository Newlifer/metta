On-disk layout:
 Bootloader (Multiboot)
 [kernel image]
 [initramdisk image]

Kernel image consists of:
 * trampoline code
 * glue code
 * nucleus code

Trampoline code is usually use-once and can be thrown away after kernel is up
and running. Trampoline code is what is being loaded by the bootloader as a
"kernel."

The glue and nucleus code are then loaded as modules specified in bootloader
or trampoline configuration.

Trampoline code then jumps to the nucleus and can later be disposed of.


Bootloader:
 - call c++ ctors
 - call kernel
 - [on return from kernel] call c++ dtors
 - halt

kernel:
 - init memory layout
 - init cpu(s) (protection, address translation, exception handlers)
   - prepare gdt and idt tables
 - find out init image location
 - unpack initramdisk to designated location
 - parse image header, find components
 - call components constructors
 - call main component entry point

component constructors:
 - run in kernel mode, have the ability to set up their system tables etcetc
 - usual components in init image include:
   - interrupt dispatcher
   - root memory manager
   - portal manager

main component entry point:
 - kserver is the first nester, that provides base Common Protocols components and boots up
   other (sub-)components such as:
   - scheduler
   - security server
   - object (security) manager

Process image

         4GB +-------------------------+ MEM_SPACE_END (Usually 4GB)
             | Last page always invalid| 0xFFFFFFFF (invalid address)
             |_________________________| 0xFFFFF000
             | Kernel stacks area:     | K_STACKS_START
             | a few 4K stacks.        | Per-CPU stacks go here in interrupt model kernel.
             | Kernel stack end        | Per-thread stacks are scattered over the heap.
             |_________________________| K_STACKS_END
             |                         | K_HEAP_END
             |                         |
             | Kernel heap             |
             |                         |
             |_________________________| K_HEAP_START
             | Kernel initial ramdisk  |
             | and init (kserver)      | Initial ramdisk contains MD drivers absolutely
             | loaded here by grub.    | required for kserver startup (APIC, other HW, root FS).
             |                         | May be replaced later by more advanced components.
             |_________________________|
             | Kernel startup code     |
             | loaded page aligned     | We allocate very limited amount of objects before
             | and then overwritten    | initializing heap. Probably these allocations can
             | for memory allocation   | be avoided completely and this area reclaimed.
             | before heap initialized |
             |_________________________| placement_address (could be == K_HEAP_START)
             | Kernel itself           |
             | - low level memory,     |
             | interrupts, portals     |
             | and nesting support.    | K_SPACE_START
      3.75GB |_________________________| 0xF0000000
             | Small spaces area for   | K_IPCS_END
             | fast IPC between user   |
             | servers.                |
      3.25GB |_________________________| K_IPCS_START 0xD0000000
             |                         |
             | Process pagetables.     | R/o from userspace, might not be needed if we expose
             |                         | a different API.
             |                         |
             |_________________________| U_RO_PAGE_TABLES 0xC8000000
             |                         |
             | ....................... |
             | nothing, unmapped       |
             | ....................... |
             |_________________________| K_TRAP_PAGES_END
             | 1 or more pages:        |
             | Usermode traps for      |
             | kernel API              |
             |_________________________| 0xC0001000 kernel traps entry page (K_TRAP_PAGES_START)
             | Kernel info page        | K_INTF_PAGE
         3GB |_________________________| 0xC0000000 kernel info/interface page (L4-like)
             |                         |
             | Guarded userspace stack | U_PROC_END (Usually 3GB) end of process space
             |    (4 pages)            | U_STACK_START
             |_________________________| U_STACK_END
             | Libraries mapped from   | U_LIBS_START
             | here downwards.         |
             |                         |
             | Portal tables are held  |
             | between loaded libraries|
             | and allocated on-demand.|
             |                         |
             | ....................... |
             | ....................... |
             |                         |
             |_________________________| Unmapped heap watermark page at heap end for growing
             | Heap guard page         | process heap a-la brk()/sbrk() with system oom checks.
             |_________________________|
             |                         | U_HEAP_END
             | User heap here          |
             | growing upwards.        |
             |_________________________| U_HEAP_START (dynamically set by start-up code)
             | Code, data, bss         |
         1MB |_________________________| 1 MB 0x100000 U_CODE_START start of code in process image
             |                         |
             | Usually unmapped space  |
             | or used by device       |
             | drivers for mapping DMA |
             | and I/O resources in    |
             | low memory (1-1 phys    |
             | mapping?), VM86 area.   |
             |_________________________|
             | Unmapped 4K page.       |            (first page reserved)
             | may be mapped for VM86  |
             | tasks to access BDA     |
         0x0 +_________________________+ 0x00000000 (invalid address)


Continuations vs threads

Any continuation to which a user program can generate a valid reference is already suspended and waiting for a message. Throw() and ThrowCC() just hand the suspended continuation a message and run it. ThrowCC() suspends the current continuation and passes it as part of the message.

throw_cc(scheduler,&message_to_scheduler,sizeof(message_to_scheduler),&received_message,sizeof(received_message));

For scheduler being some kind of identifier naming the suspended continuation of a scheduler (could be anything, but a scheduler in this case), message_to_scheduler being (of course) a message to the scheduler, and received_message being a buffer to receive a message in when another continuation throws to this one.

Since ThrowCC() was invoked instead of Throw(), the kernel transforms the running CC into a suspended continuation and prepends the identifier to that continuation to the intended message, creating the message it finally passes to the invoked scheduler continuation. In the case of plain Throw(), the kernel would just pass the message along directly as it switches control of the processor, destroying the CC that called Throw().

[...] A continuation is what remains of an unfinished computation. [...]


== Memory Barriers (from GCC docs) ==

an acquire barrier. This means that references after the builtin cannot move to (or be speculated to) before the builtin, but previous memory stores may not be globally visible yet, and previous memory loads may not yet be satisfied.

a release barrier. This means that all previous memory stores are globally visible, and all previous memory loads have been satisfied, but following memory reads are not prevented from being speculated to before the barrier.
