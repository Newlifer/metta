On-disk layout:
 Bootloader (Multiboot)
 [kernel image]
 [initramdisk image]

Kernel image consists of:
 * trampoline code
 * glue code
 * nucleus code

Trampoline code is usually use-once and can be thrown away after kernel is up
and running. Trampoline code is what is being loaded by the bootloader as a
"kernel."

The glue and nucleus code are then loaded as modules specified in bootloader
or trampoline configuration.

Trampoline code then jumps to the nucleus and can later be disposed of.


Bootloader:
 - call c++ ctors
 - call kernel
 - [on return from kernel] call c++ dtors
 - halt

kernel:
 - init memory layout
 - init cpu(s) (protection, address translation, exception handlers)
   - prepare gdt and idt tables
 - find out init image location
 - unpack initramdisk to designated location
 - parse image header, find components
 - call components constructors
 - call main component entry point

component constructors:
 - run in kernel mode, have the ability to set up their system tables etcetc
 - usual components in init image include:
   - interrupt dispatcher
   - root memory manager
   - portal manager

main component entry point:
 - kserver is the first nester, that provides base Common Protocols components and boots up
   other (sub-)components such as:
   - scheduler
   - security server
   - object (security) manager



 Virtual RAM +-------------------------+ Virtual addresses
    (4G) top |                         | 0xFFFFFFFF (invalid address)
             |                         |            (last page reserved)
             |                         |
             |                         |
             |                         |
             |                         |
             | User heap end           | 0xDFFFFFFF
             |                         |
             | User heap start         | 0xD0000000
             | Kernel heap end         | 0xCFFFFFFF
             |                         |
             | Kernel heap start       | 0xC0000000
             |                         |
             | Stack start             | 0xB0000000
             |                         |
             | Stack end               | 0xA0000000
             |                         |
             |                         |
             |                         |
             |                         |
    0x20F000 |Libos end address        |
             |                         |
             |                         |
             |...                      |
             |                         |
             |Component3               |
             |                         |
             |                         |
             |...                      |
             |                         |
             |Component2               |
             |                         |
             |                         |
             |...                      |
             |                         |
             |Component1               |
             |[Component index]        |
    0x10F000 |Libos load address       |<-- initial placementAddress
    0x10DDEC |Kernel end address       |
             |[Interrupt handlers]     |
             |[Pagefault handler]      |
             |                         |
             |                         |
             |                         |
             |                         |
(1M)0x100000 |Kernel load address      |
             |                         |
             |                         |
             |                         |
             |                         |
             |                         |
             |                         | 0x00002000 kernel traps entry page
             |                         | 0x00001000 kernel info/interface page (L4-like)
             |                         |            (first page reserved)
         0x0 +-------------------------+ 0x00000000 (invalid address)



Continuations vs threads

Any continuation to which a user program can generate a valid reference is already suspended and waiting for a message. Throw() and ThrowCC() just hand the suspended continuation a message and run it. ThrowCC() suspends the current continuation and passes it as part of the message.

throw_cc(scheduler,&message_to_scheduler,sizeof(message_to_scheduler),&received_message,sizeof(received_message));

For scheduler being some kind of identifier naming the suspended continuation of a scheduler (could be anything, but a scheduler in this case), message_to_scheduler being (of course) a message to the scheduler, and received_message being a buffer to receive a message in when another continuation throws to this one.

Since ThrowCC() was invoked instead of Throw(), the kernel transforms the running CC into a suspended continuation and prepends the identifier to that continuation to the intended message, creating the message it finally passes to the invoked scheduler continuation. In the case of plain Throw(), the kernel would just pass the message along directly as it switches control of the processor, destroying the CC that called Throw().

[...] A continuation is what remains of an unfinished computation. [...]


== Memory Barriers (from GCC docs) ==

an acquire barrier. This means that references after the builtin cannot move to (or be speculated to) before the builtin, but previous memory stores may not be globally visible yet, and previous memory loads may not yet be satisfied.

a release barrier. This means that all previous memory stores are globally visible, and all previous memory loads have been satisfied, but following memory reads are not prevented from being speculated to before the barrier.
